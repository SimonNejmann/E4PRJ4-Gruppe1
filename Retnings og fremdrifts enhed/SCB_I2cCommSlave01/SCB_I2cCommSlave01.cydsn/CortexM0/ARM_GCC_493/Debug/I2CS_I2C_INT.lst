ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"I2CS_I2C_INT.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.I2CS_I2C_ISR,"ax",%progbits
  18              		.align	2
  19              		.global	I2CS_I2C_ISR
  20              		.code	16
  21              		.thumb_func
  22              		.type	I2CS_I2C_ISR, %function
  23              	I2CS_I2C_ISR:
  24              	.LFB0:
  25              		.file 1 ".\\Generated_Source\\PSoC4\\I2CS_I2C_INT.c"
   1:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** /***************************************************************************//**
   2:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** * \file I2CS_I2C_INT.c
   3:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** * \version 3.20
   4:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** *
   5:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** * \brief
   6:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** *  This file provides the source code to the Interrupt Service Routine for
   7:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** *  the SCB Component in I2C mode.
   8:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** *
   9:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** * Note:
  10:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** *
  11:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** ********************************************************************************
  12:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** * \copyright
  13:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** * Copyright 2013-2016, Cypress Semiconductor Corporation.  All rights reserved.
  14:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** * You may use this file only in accordance with the license, terms, conditions,
  15:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** * disclaimers, and limitations in the end user license agreement accompanying
  16:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** * the software package with which this file was provided.
  17:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** *******************************************************************************/
  18:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
  19:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** #include "I2CS_PVT.h"
  20:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** #include "I2CS_I2C_PVT.h"
  21:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** #include "cyapicallbacks.h"
  22:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
  23:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
  24:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** /*******************************************************************************
  25:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** * Function Name: I2CS_I2C_ISR
  26:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** ****************************************************************************//**
  27:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** *
  28:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** *  Handles the Interrupt Service Routine for the SCB I2C mode.
  29:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** *
  30:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** *******************************************************************************/
  31:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** CY_ISR(I2CS_I2C_ISR)
  32:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** {
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 2


  26              		.loc 1 32 0
  27              		.cfi_startproc
  28 0000 80B5     		push	{r7, lr}
  29              		.cfi_def_cfa_offset 8
  30              		.cfi_offset 7, -8
  31              		.cfi_offset 14, -4
  32 0002 82B0     		sub	sp, sp, #8
  33              		.cfi_def_cfa_offset 16
  34 0004 00AF     		add	r7, sp, #0
  35              		.cfi_def_cfa_register 7
  33:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     uint32 diffCount;
  34:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     uint32 endTransfer;
  35:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
  36:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** #ifdef I2CS_I2C_ISR_ENTRY_CALLBACK
  37:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     I2CS_I2C_ISR_EntryCallback();
  38:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** #endif /* I2CS_I2C_ISR_ENTRY_CALLBACK */
  39:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
  40:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** #if (I2CS_I2C_CUSTOM_ADDRESS_HANDLER_CONST)
  41:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     uint32 response;
  42:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
  43:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     response = I2CS_I2C_ACK_ADDR;
  44:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** #endif /* (I2CS_I2C_CUSTOM_ADDRESS_HANDLER_CONST) */
  45:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
  46:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     endTransfer = 0u; /* Continue active transfer */
  36              		.loc 1 46 0
  37 0006 0023     		mov	r3, #0
  38 0008 3B60     		str	r3, [r7]
  47:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
  48:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     /* Calls customer routine if registered */
  49:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     if(NULL != I2CS_customIntrHandler)
  39              		.loc 1 49 0
  40 000a DA4B     		ldr	r3, .L38
  41 000c 1B68     		ldr	r3, [r3]
  42 000e 002B     		cmp	r3, #0
  43 0010 02D0     		beq	.L2
  50:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     {
  51:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         I2CS_customIntrHandler();
  44              		.loc 1 51 0
  45 0012 D84B     		ldr	r3, .L38
  46 0014 1B68     		ldr	r3, [r3]
  47 0016 9847     		blx	r3
  48              	.L2:
  52:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     }
  53:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
  54:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     if(I2CS_CHECK_INTR_I2C_EC_MASKED(I2CS_INTR_I2C_EC_WAKE_UP))
  49              		.loc 1 54 0
  50 0018 D74B     		ldr	r3, .L38+4
  51 001a 1B68     		ldr	r3, [r3]
  52 001c 0122     		mov	r2, #1
  53 001e 1340     		and	r3, r2
  54 0020 02D0     		beq	.L3
  55:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     {
  56:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         /* Mask-off after wakeup */
  57:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         I2CS_SetI2CExtClkInterruptMode(I2CS_NO_INTR_SOURCES);
  55              		.loc 1 57 0
  56 0022 D64B     		ldr	r3, .L38+8
  57 0024 0022     		mov	r2, #0
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 3


  58 0026 1A60     		str	r2, [r3]
  59              	.L3:
  58:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     }
  59:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
  60:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     /* Master and Slave error tracking:
  61:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     * Add the master state check to track only the master errors when the master is active or
  62:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     * track slave errors when the slave is active or idle.
  63:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     * A special MMS case: in the address phase with misplaced Start: the master sets the LOST_ARB a
  64:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     * slave BUS_ERR. The valid event is LOST_ARB comes from the master.
  65:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     */
  66:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     if(I2CS_CHECK_I2C_FSM_MASTER)
  60              		.loc 1 66 0
  61 0028 D54B     		ldr	r3, .L38+12
  62 002a 1B78     		ldrb	r3, [r3]
  63 002c DBB2     		uxtb	r3, r3
  64 002e 2022     		mov	r2, #32
  65 0030 1340     		and	r3, r2
  66 0032 DBB2     		uxtb	r3, r3
  67 0034 002B     		cmp	r3, #0
  68 0036 32D1     		bne	.L4
  67:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     {
  68:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         #if(I2CS_I2C_MASTER)
  69:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         {
  70:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             /* INTR_MASTER_I2C_BUS_ERROR:
  71:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * A misplaced Start or Stop condition occurred on the bus: complete the transaction.
  72:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * The interrupt is cleared in I2C_FSM_EXIT_IDLE.
  73:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             */
  74:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             if(I2CS_CHECK_INTR_MASTER_MASKED(I2CS_INTR_MASTER_I2C_BUS_ERROR))
  75:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             {
  76:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_mstrStatus |= (uint16) (I2CS_I2C_MSTAT_ERR_XFER |
  77:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                                          I2CS_I2C_MSTAT_ERR_BUS_ERROR);
  78:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
  79:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 endTransfer = I2CS_I2C_CMPLT_ANY_TRANSFER;
  80:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             }
  81:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
  82:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             /* INTR_MASTER_I2C_ARB_LOST:
  83:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * The MultiMaster lost arbitrage during transaction.
  84:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * A Misplaced Start or Stop condition is treated as lost arbitration when the master dr
  85:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * The interrupt source is cleared in I2C_FSM_EXIT_IDLE.
  86:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             */
  87:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             if(I2CS_CHECK_INTR_MASTER_MASKED(I2CS_INTR_MASTER_I2C_ARB_LOST))
  88:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             {
  89:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_mstrStatus |= (uint16) (I2CS_I2C_MSTAT_ERR_XFER |
  90:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                                          I2CS_I2C_MSTAT_ERR_ARB_LOST);
  91:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
  92:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 endTransfer = I2CS_I2C_CMPLT_ANY_TRANSFER;
  93:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             }
  94:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
  95:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             #if(I2CS_I2C_MULTI_MASTER_SLAVE)
  96:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             {
  97:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 /* I2C_MASTER_CMD_M_START_ON_IDLE:
  98:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 * MultiMaster-Slave does not generate start, because Slave was addressed.
  99:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 * Pass control to slave.
 100:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 */
 101:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 if(I2CS_CHECK_I2C_MASTER_CMD(I2CS_I2C_MASTER_CMD_M_START_ON_IDLE))
 102:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 103:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_mstrStatus |= (uint16) (I2CS_I2C_MSTAT_ERR_XFER |
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 4


 104:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                                              I2CS_I2C_MSTAT_ERR_ABORT_XFER);
 105:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 106:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     endTransfer = I2CS_I2C_CMPLT_ANY_TRANSFER;
 107:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 108:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             }
 109:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             #endif
 110:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 111:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             /* The error handling common part:
 112:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * Sets a completion flag of the master transaction and passes control to:
 113:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             *  - I2C_FSM_EXIT_IDLE - to complete transaction in case of: ARB_LOST or BUS_ERR.
 114:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             *  - I2C_FSM_IDLE      - to take chance for the slave to process incoming transaction.
 115:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             */
 116:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             if(0u != endTransfer)
 117:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             {
 118:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 /* Set completion flags for master */
 119:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_mstrStatus |= (uint16) I2CS_GET_I2C_MSTAT_CMPLT;
 120:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 121:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 #if(I2CS_I2C_MULTI_MASTER_SLAVE)
 122:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 123:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     if(I2CS_CHECK_I2C_FSM_ADDR)
 124:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 125:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* Start generation is set after another master starts accessing Slave.
 126:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * Clean-up master and turn to slave. Set state to IDLE.
 127:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         */
 128:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         if(I2CS_CHECK_I2C_MASTER_CMD(I2CS_I2C_MASTER_CMD_M_START_ON_IDLE))
 129:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 130:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_I2C_MASTER_CLEAR_START;
 131:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 132:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             endTransfer = I2CS_I2C_CMPLT_ANY_TRANSFER; /* Pass control to Slave */
 133:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 134:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* Valid arbitration lost on the address phase happens only when: master LO
 135:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * slave BUS_ERR is cleared. Only in that case set the state to IDLE without
 136:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         */
 137:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         else if((!I2CS_CHECK_INTR_SLAVE_MASKED(I2CS_INTR_SLAVE_I2C_BUS_ERROR))
 138:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                && I2CS_CHECK_INTR_MASTER_MASKED(I2CS_INTR_MASTER_I2C_ARB_LOST))
 139:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 140:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             endTransfer = I2CS_I2C_CMPLT_ANY_TRANSFER; /* Pass control to Slave */
 141:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 142:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         else
 143:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 144:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             endTransfer = 0u; /* Causes I2C_FSM_EXIT_IDLE to be set below */
 145:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 146:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 147:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         if(0u != endTransfer) /* Clean-up master to proceed with slave */
 148:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 149:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_CLEAR_TX_FIFO; /* Shifter keeps address, clear it */
 150:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 151:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_DISABLE_MASTER_AUTO_DATA_ACK; /* In case of reading disable autoAC
 152:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 153:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Clean-up master interrupt sources */
 154:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_ClearMasterInterruptSource(I2CS_INTR_MASTER_ALL);
 155:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 156:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Disable data processing interrupts: they have to be cleared before *
 157:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_SetRxInterruptMode(I2CS_NO_INTR_SOURCES);
 158:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_SetTxInterruptMode(I2CS_NO_INTR_SOURCES);
 159:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 160:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_state = I2CS_I2C_FSM_IDLE;
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 5


 161:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 162:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         else
 163:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 164:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Set I2C_FSM_EXIT_IDLE for BUS_ERR and ARB_LOST (that is really bus e
 165:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_state = I2CS_I2C_FSM_EXIT_IDLE;
 166:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 167:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 168:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     else
 169:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 170:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* Set I2C_FSM_EXIT_IDLE if any other state than address */
 171:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_state = I2CS_I2C_FSM_EXIT_IDLE;
 172:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 173:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 174:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 #else
 175:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 176:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* In case of LOST*/
 177:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_state = I2CS_I2C_FSM_EXIT_IDLE;
 178:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 179:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 #endif
 180:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             }
 181:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         }
 182:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         #endif
 183:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     }
 184:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     else /* (I2CS_CHECK_I2C_FSM_SLAVE) */
 185:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     {
 186:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         #if(I2CS_I2C_SLAVE)
 187:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         {
 188:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             /* INTR_SLAVE_I2C_BUS_ERROR or I2CS_INTR_SLAVE_I2C_ARB_LOST:
 189:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * A Misplaced Start or Stop condition occurred on the bus: set a flag
 190:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * to notify an error condition.
 191:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             */
 192:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             if(I2CS_CHECK_INTR_SLAVE_MASKED(I2CS_INTR_SLAVE_I2C_BUS_ERROR |
  69              		.loc 1 192 0
  70 0038 D24B     		ldr	r3, .L38+16
  71 003a 1A68     		ldr	r2, [r3]
  72 003c 0223     		mov	r3, #2
  73 003e FF33     		add	r3, r3, #255
  74 0040 1340     		and	r3, r2
  75 0042 2CD0     		beq	.L4
 193:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                                         I2CS_INTR_SLAVE_I2C_ARB_LOST))
 194:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             {
 195:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 if(I2CS_CHECK_I2C_FSM_RD)
  76              		.loc 1 195 0
  77 0044 CE4B     		ldr	r3, .L38+12
  78 0046 1B78     		ldrb	r3, [r3]
  79 0048 DBB2     		uxtb	r3, r3
  80 004a 0122     		mov	r2, #1
  81 004c 1340     		and	r3, r2
  82 004e DBB2     		uxtb	r3, r3
  83 0050 002B     		cmp	r3, #0
  84 0052 10D0     		beq	.L5
 196:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 197:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* TX direction: master reads from slave */
 198:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_slStatus &= (uint8) ~I2CS_I2C_SSTAT_RD_BUSY;
  85              		.loc 1 198 0
  86 0054 CC4B     		ldr	r3, .L38+20
  87 0056 1B78     		ldrb	r3, [r3]
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 6


  88 0058 DBB2     		uxtb	r3, r3
  89 005a 0222     		mov	r2, #2
  90 005c 9343     		bic	r3, r2
  91 005e DAB2     		uxtb	r2, r3
  92 0060 C94B     		ldr	r3, .L38+20
  93 0062 1A70     		strb	r2, [r3]
 199:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_slStatus |= (uint8) (I2CS_I2C_SSTAT_RD_ERR |
  94              		.loc 1 199 0
  95 0064 C84B     		ldr	r3, .L38+20
  96 0066 1B78     		ldrb	r3, [r3]
  97 0068 DBB2     		uxtb	r3, r3
  98 006a 0922     		mov	r2, #9
  99 006c 1343     		orr	r3, r2
 100 006e DAB2     		uxtb	r2, r3
 101 0070 C54B     		ldr	r3, .L38+20
 102 0072 1A70     		strb	r2, [r3]
 103 0074 10E0     		b	.L6
 104              	.L5:
 200:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                                           I2CS_I2C_SSTAT_RD_CMPLT);
 201:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 202:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 else
 203:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 204:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* RX direction: master writes into slave */
 205:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_slStatus &= (uint8) ~I2CS_I2C_SSTAT_WR_BUSY;
 105              		.loc 1 205 0
 106 0076 C44B     		ldr	r3, .L38+20
 107 0078 1B78     		ldrb	r3, [r3]
 108 007a DBB2     		uxtb	r3, r3
 109 007c 2022     		mov	r2, #32
 110 007e 9343     		bic	r3, r2
 111 0080 DAB2     		uxtb	r2, r3
 112 0082 C14B     		ldr	r3, .L38+20
 113 0084 1A70     		strb	r2, [r3]
 206:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_slStatus |= (uint8) (I2CS_I2C_SSTAT_WR_ERR |
 114              		.loc 1 206 0
 115 0086 C04B     		ldr	r3, .L38+20
 116 0088 1B78     		ldrb	r3, [r3]
 117 008a DBB2     		uxtb	r3, r3
 118 008c 7022     		mov	r2, #112
 119 008e 5242     		neg	r2, r2
 120 0090 1343     		orr	r3, r2
 121 0092 DAB2     		uxtb	r2, r3
 122 0094 BC4B     		ldr	r3, .L38+20
 123 0096 1A70     		strb	r2, [r3]
 124              	.L6:
 207:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                                           I2CS_I2C_SSTAT_WR_CMPLT);
 208:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 209:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 210:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_state = I2CS_I2C_FSM_EXIT_IDLE;
 125              		.loc 1 210 0
 126 0098 B94B     		ldr	r3, .L38+12
 127 009a 0022     		mov	r2, #0
 128 009c 1A70     		strb	r2, [r3]
 129              	.L4:
 211:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             }
 212:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         }
 213:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         #endif
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 7


 214:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     }
 215:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 216:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     /* States description:
 217:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     * Any Master operation starts from: the ADDR_RD/WR state as the master generates traffic on the
 218:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     * Any Slave operation starts from: the IDLE state as the slave always waits for actions from th
 219:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     */
 220:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 221:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     /* FSM Master */
 222:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     if(I2CS_CHECK_I2C_FSM_MASTER)
 130              		.loc 1 222 0
 131 009e B84B     		ldr	r3, .L38+12
 132 00a0 1B78     		ldrb	r3, [r3]
 133 00a2 DBB2     		uxtb	r3, r3
 134 00a4 2022     		mov	r2, #32
 135 00a6 1340     		and	r3, r2
 136 00a8 DBB2     		uxtb	r3, r3
 137 00aa 002B     		cmp	r3, #0
 138 00ac 00D0     		beq	.LCB108
 139 00ae 0AE2     		b	.L1	@long jump
 140              	.LCB108:
 223:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     {
 224:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         #if(I2CS_I2C_MASTER)
 225:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         {
 226:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             /* INTR_MASTER_I2C_STOP:
 227:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * A Stop condition was generated by the master: the end of the transaction.
 228:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * Set completion flags to notify the API.
 229:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             */
 230:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             if(I2CS_CHECK_INTR_MASTER_MASKED(I2CS_INTR_MASTER_I2C_STOP))
 231:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             {
 232:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_ClearMasterInterruptSource(I2CS_INTR_MASTER_I2C_STOP);
 233:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 234:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_mstrStatus |= (uint16) I2CS_GET_I2C_MSTAT_CMPLT;
 235:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_state       = I2CS_I2C_FSM_IDLE;
 236:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             }
 237:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             else
 238:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             {
 239:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 if(I2CS_CHECK_I2C_FSM_ADDR) /* Address stage */
 240:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 241:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* INTR_MASTER_I2C_NACK:
 242:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     * The master sent an address but it was NACKed by the slave. Complete transacti
 243:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     */
 244:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     if(I2CS_CHECK_INTR_MASTER_MASKED(I2CS_INTR_MASTER_I2C_NACK))
 245:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 246:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_ClearMasterInterruptSource(I2CS_INTR_MASTER_I2C_NACK);
 247:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 248:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_mstrStatus |= (uint16) (I2CS_I2C_MSTAT_ERR_XFER |
 249:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                                                  I2CS_I2C_MSTAT_ERR_ADDR_NAK);
 250:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 251:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         endTransfer = I2CS_I2C_CMPLT_ANY_TRANSFER;
 252:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 253:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* INTR_TX_UNDERFLOW. The master sent an address:
 254:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     *  - TX direction: the clock is stretched after the ACK phase, because the TX F
 255:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     *    EMPTY. The TX EMPTY cleans all the TX interrupt sources.
 256:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     *  - RX direction: the 1st byte is received, but there is no ACK permission,
 257:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     *    the clock is stretched after 1 byte is received.
 258:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     */
 259:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     else
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 8


 260:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 261:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         if(I2CS_CHECK_I2C_FSM_RD) /* Reading */
 262:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 263:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_state = I2CS_I2C_FSM_MSTR_RD_DATA;
 264:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 265:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         else /* Writing */
 266:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 267:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_state = I2CS_I2C_FSM_MSTR_WR_DATA;
 268:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             if(0u != I2CS_mstrWrBufSize)
 269:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             {
 270:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 /* Enable INTR.TX_EMPTY if there is data to transmit */
 271:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 I2CS_SetTxInterruptMode(I2CS_INTR_TX_EMPTY);
 272:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             }
 273:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 274:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 275:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 276:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 277:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 if(I2CS_CHECK_I2C_FSM_DATA) /* Data phase */
 278:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 279:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     if(I2CS_CHECK_I2C_FSM_RD) /* Reading */
 280:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 281:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* INTR_RX_FULL:
 282:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * RX direction: the master received 8 bytes.
 283:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * Get data from RX FIFO and decide whether to ACK or  NACK the following by
 284:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         */
 285:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         if(I2CS_CHECK_INTR_RX_MASKED(I2CS_INTR_RX_FULL))
 286:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 287:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Calculate difference */
 288:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             diffCount =  I2CS_mstrRdBufSize -
 289:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                         (I2CS_mstrRdBufIndex + I2CS_GET_RX_FIFO_ENTRIES);
 290:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 291:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Proceed transaction or end it when RX FIFO becomes FULL again */
 292:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             if(diffCount > I2CS_I2C_FIFO_SIZE)
 293:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             {
 294:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 diffCount = I2CS_I2C_FIFO_SIZE;
 295:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             }
 296:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             else
 297:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             {
 298:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 if(0u == diffCount)
 299:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 {
 300:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     I2CS_DISABLE_MASTER_AUTO_DATA_ACK;
 301:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 302:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     diffCount   = I2CS_I2C_FIFO_SIZE;
 303:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     endTransfer = I2CS_I2C_CMPLT_ANY_TRANSFER;
 304:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 }
 305:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             }
 306:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 307:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             for(; (0u != diffCount); diffCount--)
 308:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             {
 309:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 I2CS_mstrRdBufPtr[I2CS_mstrRdBufIndex] = (uint8)
 310:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                                                                         I2CS_RX_FIF
 311:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 I2CS_mstrRdBufIndex++;
 312:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             }
 313:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 314:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* INTR_RX_NOT_EMPTY:
 315:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * RX direction: the master received one data byte, ACK or NACK it.
 316:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * The last byte is stored and NACKed by the master. The NACK and Stop is
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 9


 317:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * generated by one command generate Stop.
 318:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         */
 319:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         else if(I2CS_CHECK_INTR_RX_MASKED(I2CS_INTR_RX_NOT_EMPTY))
 320:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 321:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Put data in component buffer */
 322:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_mstrRdBufPtr[I2CS_mstrRdBufIndex] = (uint8) I2CS_RX_FIFO_RD_REG;
 323:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_mstrRdBufIndex++;
 324:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 325:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             if(I2CS_mstrRdBufIndex < I2CS_mstrRdBufSize)
 326:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             {
 327:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 I2CS_I2C_MASTER_GENERATE_ACK;
 328:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             }
 329:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             else
 330:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             {
 331:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                endTransfer = I2CS_I2C_CMPLT_ANY_TRANSFER;
 332:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             }
 333:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 334:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         else
 335:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 336:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Do nothing */
 337:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 338:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 339:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_ClearRxInterruptSource(I2CS_INTR_RX_ALL);
 340:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 341:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     else /* Writing */
 342:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 343:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* INTR_MASTER_I2C_NACK :
 344:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * The master writes data to the slave and NACK was received: not all the by
 345:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * written to the slave from the TX FIFO. Revert the index if there is data 
 346:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * the TX FIFO and pass control to a complete transfer.
 347:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         */
 348:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         if(I2CS_CHECK_INTR_MASTER_MASKED(I2CS_INTR_MASTER_I2C_NACK))
 349:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 350:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_ClearMasterInterruptSource(I2CS_INTR_MASTER_I2C_NACK);
 351:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 352:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Rollback write buffer index: NACKed byte remains in shifter */
 353:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_mstrWrBufIndexTmp -= (I2CS_GET_TX_FIFO_ENTRIES +
 354:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                                                    I2CS_GET_TX_FIFO_SR_VALID);
 355:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 356:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Update number of transferred bytes */
 357:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_mstrWrBufIndex = I2CS_mstrWrBufIndexTmp;
 358:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 359:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_mstrStatus |= (uint16) (I2CS_I2C_MSTAT_ERR_XFER |
 360:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                                                      I2CS_I2C_MSTAT_ERR_SHORT_XFER)
 361:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 362:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_CLEAR_TX_FIFO;
 363:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 364:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             endTransfer = I2CS_I2C_CMPLT_ANY_TRANSFER;
 365:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 366:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* INTR_TX_EMPTY :
 367:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * TX direction: the TX FIFO is EMPTY, the data from the buffer needs to be 
 368:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * When there is no data in the component buffer, the underflow interrupt is
 369:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * enabled to catch when all the data has been transferred.
 370:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         */
 371:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         else if(I2CS_CHECK_INTR_TX_MASKED(I2CS_INTR_TX_EMPTY))
 372:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 373:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             while(I2CS_I2C_FIFO_SIZE != I2CS_GET_TX_FIFO_ENTRIES)
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 10


 374:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             {
 375:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 /* The temporary mstrWrBufIndexTmp is used because slave could NACK
 376:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 * roll-back required in this case. The mstrWrBufIndex is updated at
 377:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 */
 378:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 if(I2CS_mstrWrBufIndexTmp < I2CS_mstrWrBufSize)
 379:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 {
 380:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 #if(!I2CS_CY_SCBIP_V0)
 381:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                    /* Clear INTR_TX.UNDERFLOW before putting the last byte into TX 
 382:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     * a proper trigger at the end of transaction when INTR_TX.UNDER
 383:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     * event. Ticket ID# 156735.
 384:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     */
 385:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     if(I2CS_mstrWrBufIndexTmp == (I2CS_mstrWrBufSize - 1u))
 386:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     {
 387:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                         I2CS_ClearTxInterruptSource(I2CS_INTR_TX_UNDERFLOW);
 388:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                         I2CS_SetTxInterruptMode(I2CS_INTR_TX_UNDERFLOW);
 389:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     }
 390:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                  #endif /* (!I2CS_CY_SCBIP_V0) */
 391:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 392:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     /* Put data into TX FIFO */
 393:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     I2CS_TX_FIFO_WR_REG = (uint32) I2CS_mstrWrBufPtr[I2CS_mstrWrBuf
 394:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     I2CS_mstrWrBufIndexTmp++;
 395:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 }
 396:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 else
 397:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 {
 398:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     break; /* No more data to put */
 399:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 }
 400:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             }
 401:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 402:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         #if(I2CS_CY_SCBIP_V0)
 403:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             if(I2CS_mstrWrBufIndexTmp == I2CS_mstrWrBufSize)
 404:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             {
 405:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 I2CS_SetTxInterruptMode(I2CS_INTR_TX_UNDERFLOW);
 406:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             }
 407:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 408:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_ClearTxInterruptSource(I2CS_INTR_TX_ALL);
 409:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         #else
 410:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_ClearTxInterruptSource(I2CS_INTR_TX_EMPTY);
 411:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         #endif /* (I2CS_CY_SCBIP_V0) */
 412:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 413:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* INTR_TX_UNDERFLOW:
 414:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * TX direction: all data from the TX FIFO was transferred to the slave.
 415:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * The transaction needs to be completed.
 416:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         */
 417:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         else if(I2CS_CHECK_INTR_TX_MASKED(I2CS_INTR_TX_UNDERFLOW))
 418:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 419:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Update number of transferred bytes */
 420:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_mstrWrBufIndex = I2CS_mstrWrBufIndexTmp;
 421:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 422:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             endTransfer = I2CS_I2C_CMPLT_ANY_TRANSFER;
 423:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 424:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         else
 425:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 426:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Do nothing */
 427:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 428:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 429:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 430:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 11


 431:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 if(0u != endTransfer) /* Complete transfer */
 432:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 433:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* Clean-up master after reading: only in case of NACK */
 434:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_DISABLE_MASTER_AUTO_DATA_ACK;
 435:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 436:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* Disable data processing interrupts: they have to be cleared before */
 437:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_SetRxInterruptMode(I2CS_NO_INTR_SOURCES);
 438:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_SetTxInterruptMode(I2CS_NO_INTR_SOURCES);
 439:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 440:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     if(I2CS_CHECK_I2C_MODE_NO_STOP(I2CS_mstrControl))
 441:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 442:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* On-going transaction is suspended: the ReStart is generated by the API r
 443:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_mstrStatus |= (uint16) (I2CS_I2C_MSTAT_XFER_HALT |
 444:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                                                  I2CS_GET_I2C_MSTAT_CMPLT);
 445:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 446:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_state = I2CS_I2C_FSM_MSTR_HALT;
 447:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 448:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     else
 449:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 450:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* Complete transaction: exclude the data processing state and generate Sto
 451:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * The completion status will be set after Stop generation.
 452:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * A special case is read: because NACK and Stop are generated by the comman
 453:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * Lost arbitration can occur during NACK generation when
 454:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * the other master is still reading from the slave.
 455:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         */
 456:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_I2C_MASTER_GENERATE_STOP;
 457:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 458:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 459:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             }
 460:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 461:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         } /* (I2CS_I2C_MASTER) */
 462:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         #endif
 463:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 464:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     } /* (I2CS_CHECK_I2C_FSM_MASTER) */
 465:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 466:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 467:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     /* FSM Slave */
 468:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     else if(I2CS_CHECK_I2C_FSM_SLAVE)
 141              		.loc 1 468 0
 142 00b0 B34B     		ldr	r3, .L38+12
 143 00b2 1B78     		ldrb	r3, [r3]
 144 00b4 DBB2     		uxtb	r3, r3
 145 00b6 1022     		mov	r2, #16
 146 00b8 1340     		and	r3, r2
 147 00ba DBB2     		uxtb	r3, r3
 148 00bc 002B     		cmp	r3, #0
 149 00be 00D1     		bne	.LCB116
 150 00c0 D3E1     		b	.L8	@long jump
 151              	.LCB116:
 469:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     {
 470:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         #if(I2CS_I2C_SLAVE)
 471:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         {
 472:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             /* INTR_SLAVE_NACK:
 473:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * The master completes reading the slave: the appropriate flags have to be set.
 474:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * The TX FIFO is cleared after an overflow condition is set.
 475:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             */
 476:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             if(I2CS_CHECK_INTR_SLAVE_MASKED(I2CS_INTR_SLAVE_I2C_NACK))
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 12


 152              		.loc 1 476 0
 153 00c2 B04B     		ldr	r3, .L38+16
 154 00c4 1B68     		ldr	r3, [r3]
 155 00c6 0222     		mov	r2, #2
 156 00c8 1340     		and	r3, r2
 157 00ca 56D0     		beq	.L9
 477:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             {
 478:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_ClearSlaveInterruptSource(I2CS_INTR_SLAVE_I2C_NACK);
 158              		.loc 1 478 0
 159 00cc AF4B     		ldr	r3, .L38+24
 160 00ce 0222     		mov	r2, #2
 161 00d0 1A60     		str	r2, [r3]
 479:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 480:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 /* All entries that remain in TX FIFO are: FIFO Size + 1 (SHIFTER) */
 481:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 diffCount = (I2CS_GET_TX_FIFO_ENTRIES + I2CS_GET_TX_FIFO_SR_VALID);
 162              		.loc 1 481 0
 163 00d2 AF4B     		ldr	r3, .L38+28
 164 00d4 1B68     		ldr	r3, [r3]
 165 00d6 0F22     		mov	r2, #15
 166 00d8 1A40     		and	r2, r3
 167 00da AD4B     		ldr	r3, .L38+28
 168 00dc 1968     		ldr	r1, [r3]
 169 00de 8023     		mov	r3, #128
 170 00e0 1B02     		lsl	r3, r3, #8
 171 00e2 0B40     		and	r3, r1
 172 00e4 01D0     		beq	.L10
 173              		.loc 1 481 0 is_stmt 0 discriminator 1
 174 00e6 0123     		mov	r3, #1
 175 00e8 00E0     		b	.L11
 176              	.L10:
 177              		.loc 1 481 0 discriminator 2
 178 00ea 0023     		mov	r3, #0
 179              	.L11:
 180              		.loc 1 481 0 discriminator 4
 181 00ec D318     		add	r3, r2, r3
 182 00ee 7B60     		str	r3, [r7, #4]
 482:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 483:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 if(I2CS_slOverFlowCount > diffCount) /* Overflow */
 183              		.loc 1 483 0 is_stmt 1 discriminator 4
 184 00f0 A84B     		ldr	r3, .L38+32
 185 00f2 1B78     		ldrb	r3, [r3]
 186 00f4 DBB2     		uxtb	r3, r3
 187 00f6 1A1E     		sub	r2, r3, #0
 188 00f8 7B68     		ldr	r3, [r7, #4]
 189 00fa 9A42     		cmp	r2, r3
 190 00fc 08D9     		bls	.L12
 484:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 485:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_slStatus |= (uint8) I2CS_I2C_SSTAT_RD_OVFL;
 191              		.loc 1 485 0
 192 00fe A24B     		ldr	r3, .L38+20
 193 0100 1B78     		ldrb	r3, [r3]
 194 0102 DBB2     		uxtb	r3, r3
 195 0104 0422     		mov	r2, #4
 196 0106 1343     		orr	r3, r2
 197 0108 DAB2     		uxtb	r2, r3
 198 010a 9F4B     		ldr	r3, .L38+20
 199 010c 1A70     		strb	r2, [r3]
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 13


 200 010e 0AE0     		b	.L13
 201              	.L12:
 486:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 487:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 else /* No Overflow */
 488:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 489:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* Roll-back temporary index */
 490:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_slRdBufIndexTmp -= (diffCount - I2CS_slOverFlowCount);
 202              		.loc 1 490 0
 203 0110 A04B     		ldr	r3, .L38+32
 204 0112 1B78     		ldrb	r3, [r3]
 205 0114 DBB2     		uxtb	r3, r3
 206 0116 1A1C     		mov	r2, r3
 207 0118 7B68     		ldr	r3, [r7, #4]
 208 011a 9A1A     		sub	r2, r3, r2
 209 011c 9E4B     		ldr	r3, .L38+36
 210 011e 1B68     		ldr	r3, [r3]
 211 0120 9A1A     		sub	r2, r3, r2
 212 0122 9D4B     		ldr	r3, .L38+36
 213 0124 1A60     		str	r2, [r3]
 214              	.L13:
 491:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 492:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 493:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 /* Update slave of transferred bytes */
 494:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_slRdBufIndex = I2CS_slRdBufIndexTmp;
 215              		.loc 1 494 0
 216 0126 9C4B     		ldr	r3, .L38+36
 217 0128 1A68     		ldr	r2, [r3]
 218 012a 9C4B     		ldr	r3, .L38+40
 219 012c 1A60     		str	r2, [r3]
 495:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 496:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 /* Clean-up TX FIFO */
 497:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_SetTxInterruptMode(I2CS_NO_INTR_SOURCES);
 220              		.loc 1 497 0
 221 012e 9C4B     		ldr	r3, .L38+44
 222 0130 0022     		mov	r2, #0
 223 0132 1A60     		str	r2, [r3]
 498:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_slOverFlowCount = 0u;
 224              		.loc 1 498 0
 225 0134 974B     		ldr	r3, .L38+32
 226 0136 0022     		mov	r2, #0
 227 0138 1A70     		strb	r2, [r3]
 499:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_CLEAR_TX_FIFO;
 228              		.loc 1 499 0
 229 013a 9A4B     		ldr	r3, .L38+48
 230 013c 994A     		ldr	r2, .L38+48
 231 013e 1268     		ldr	r2, [r2]
 232 0140 8021     		mov	r1, #128
 233 0142 4902     		lsl	r1, r1, #9
 234 0144 0A43     		orr	r2, r1
 235 0146 1A60     		str	r2, [r3]
 236 0148 964B     		ldr	r3, .L38+48
 237 014a 964A     		ldr	r2, .L38+48
 238 014c 1268     		ldr	r2, [r2]
 239 014e 9649     		ldr	r1, .L38+52
 240 0150 0A40     		and	r2, r1
 241 0152 1A60     		str	r2, [r3]
 500:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 14


 501:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 /* Complete master reading */
 502:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_slStatus &= (uint8) ~I2CS_I2C_SSTAT_RD_BUSY;
 242              		.loc 1 502 0
 243 0154 8C4B     		ldr	r3, .L38+20
 244 0156 1B78     		ldrb	r3, [r3]
 245 0158 DBB2     		uxtb	r3, r3
 246 015a 0222     		mov	r2, #2
 247 015c 9343     		bic	r3, r2
 248 015e DAB2     		uxtb	r2, r3
 249 0160 894B     		ldr	r3, .L38+20
 250 0162 1A70     		strb	r2, [r3]
 503:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_slStatus |= (uint8)  I2CS_I2C_SSTAT_RD_CMPLT;
 251              		.loc 1 503 0
 252 0164 884B     		ldr	r3, .L38+20
 253 0166 1B78     		ldrb	r3, [r3]
 254 0168 DBB2     		uxtb	r3, r3
 255 016a 0122     		mov	r2, #1
 256 016c 1343     		orr	r3, r2
 257 016e DAB2     		uxtb	r2, r3
 258 0170 854B     		ldr	r3, .L38+20
 259 0172 1A70     		strb	r2, [r3]
 504:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_state     =  I2CS_I2C_FSM_IDLE;
 260              		.loc 1 504 0
 261 0174 824B     		ldr	r3, .L38+12
 262 0176 1022     		mov	r2, #16
 263 0178 1A70     		strb	r2, [r3]
 264              	.L9:
 505:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             }
 506:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 507:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 508:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             /* INTR_SLAVE_I2C_WRITE_STOP:
 509:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * The master completes writing to the slave: the appropriate flags have to be set.
 510:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * The RX FIFO contains 1-8 bytes from the previous transaction which needs to be read.
 511:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * There is a possibility that RX FIFO contains an address, it needs to leave it there.
 512:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             */
 513:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             if(I2CS_CHECK_INTR_SLAVE_MASKED(I2CS_INTR_SLAVE_I2C_WRITE_STOP))
 265              		.loc 1 513 0
 266 017a 824B     		ldr	r3, .L38+16
 267 017c 1B68     		ldr	r3, [r3]
 268 017e 0822     		mov	r2, #8
 269 0180 1340     		and	r3, r2
 270 0182 48D0     		beq	.L14
 514:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             {
 515:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_ClearSlaveInterruptSource(I2CS_INTR_SLAVE_I2C_WRITE_STOP);
 271              		.loc 1 515 0
 272 0184 814B     		ldr	r3, .L38+24
 273 0186 0822     		mov	r2, #8
 274 0188 1A60     		str	r2, [r3]
 516:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 517:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 /* Read bytes from RX FIFO when auto data ACK receive logic is enabled. Otherwise a
 518:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 * were already read from the RX FIFO except for address byte which has to stay here
 519:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 * I2C_ADDR_MATCH.
 520:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 */
 521:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 if (0u != (I2CS_I2C_CTRL_REG & I2CS_I2C_CTRL_S_READY_DATA_ACK))
 275              		.loc 1 521 0
 276 018a 884B     		ldr	r3, .L38+56
 277 018c 1A68     		ldr	r2, [r3]
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 15


 278 018e 8023     		mov	r3, #128
 279 0190 9B01     		lsl	r3, r3, #6
 280 0192 1340     		and	r3, r2
 281 0194 19D0     		beq	.L15
 522:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 523:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     while(0u != I2CS_GET_RX_FIFO_ENTRIES)
 282              		.loc 1 523 0
 283 0196 0DE0     		b	.L16
 284              	.L17:
 524:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 525:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         #if(I2CS_CHECK_I2C_ACCEPT_ADDRESS)
 526:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 527:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             if((1u == I2CS_GET_RX_FIFO_ENTRIES) &&
 528:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                (I2CS_CHECK_INTR_SLAVE_MASKED(I2CS_INTR_SLAVE_I2C_ADDR_MATCH)))
 529:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             {
 530:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 break; /* Leave address in RX FIFO */
 531:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             }
 532:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 533:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         #endif
 534:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 535:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* Put data in component buffer */
 536:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_slWrBufPtr[I2CS_slWrBufIndex] = (uint8) I2CS_RX_FIFO_RD_REG;
 285              		.loc 1 536 0
 286 0198 854B     		ldr	r3, .L38+60
 287 019a 1A68     		ldr	r2, [r3]
 288 019c 854B     		ldr	r3, .L38+64
 289 019e 1B68     		ldr	r3, [r3]
 290 01a0 D218     		add	r2, r2, r3
 291 01a2 854B     		ldr	r3, .L38+68
 292 01a4 1B68     		ldr	r3, [r3]
 293 01a6 DBB2     		uxtb	r3, r3
 294 01a8 1370     		strb	r3, [r2]
 537:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_slWrBufIndex++;
 295              		.loc 1 537 0
 296 01aa 824B     		ldr	r3, .L38+64
 297 01ac 1B68     		ldr	r3, [r3]
 298 01ae 5A1C     		add	r2, r3, #1
 299 01b0 804B     		ldr	r3, .L38+64
 300 01b2 1A60     		str	r2, [r3]
 301              	.L16:
 523:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 302              		.loc 1 523 0
 303 01b4 814B     		ldr	r3, .L38+72
 304 01b6 1B68     		ldr	r3, [r3]
 305 01b8 0F22     		mov	r2, #15
 306 01ba 1340     		and	r3, r2
 307 01bc ECD1     		bne	.L17
 538:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 539:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 540:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_DISABLE_SLAVE_AUTO_DATA;
 308              		.loc 1 540 0
 309 01be 7B4B     		ldr	r3, .L38+56
 310 01c0 7A4A     		ldr	r2, .L38+56
 311 01c2 1268     		ldr	r2, [r2]
 312 01c4 7E49     		ldr	r1, .L38+76
 313 01c6 0A40     		and	r2, r1
 314 01c8 1A60     		str	r2, [r3]
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 16


 315              	.L15:
 541:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 542:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 543:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 if(I2CS_CHECK_INTR_RX(I2CS_INTR_RX_OVERFLOW))
 316              		.loc 1 543 0
 317 01ca 7E4B     		ldr	r3, .L38+80
 318 01cc 1B68     		ldr	r3, [r3]
 319 01ce 2022     		mov	r2, #32
 320 01d0 1340     		and	r3, r2
 321 01d2 07D0     		beq	.L18
 544:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 545:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_slStatus |= (uint8) I2CS_I2C_SSTAT_WR_OVFL;
 322              		.loc 1 545 0
 323 01d4 6C4B     		ldr	r3, .L38+20
 324 01d6 1B78     		ldrb	r3, [r3]
 325 01d8 DBB2     		uxtb	r3, r3
 326 01da 4022     		mov	r2, #64
 327 01dc 1343     		orr	r3, r2
 328 01de DAB2     		uxtb	r2, r3
 329 01e0 694B     		ldr	r3, .L38+20
 330 01e2 1A70     		strb	r2, [r3]
 331              	.L18:
 546:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 547:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 548:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 /* Clears RX interrupt sources triggered on data receiving */
 549:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_SetRxInterruptMode(I2CS_NO_INTR_SOURCES);
 332              		.loc 1 549 0
 333 01e4 784B     		ldr	r3, .L38+84
 334 01e6 0022     		mov	r2, #0
 335 01e8 1A60     		str	r2, [r3]
 550:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_ClearRxInterruptSource(I2CS_INTR_RX_ALL);
 336              		.loc 1 550 0
 337 01ea 764B     		ldr	r3, .L38+80
 338 01ec 774A     		ldr	r2, .L38+88
 339 01ee 1A60     		str	r2, [r3]
 551:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 552:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 /* Complete master writing */
 553:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_slStatus &= (uint8) ~I2CS_I2C_SSTAT_WR_BUSY;
 340              		.loc 1 553 0
 341 01f0 654B     		ldr	r3, .L38+20
 342 01f2 1B78     		ldrb	r3, [r3]
 343 01f4 DBB2     		uxtb	r3, r3
 344 01f6 2022     		mov	r2, #32
 345 01f8 9343     		bic	r3, r2
 346 01fa DAB2     		uxtb	r2, r3
 347 01fc 624B     		ldr	r3, .L38+20
 348 01fe 1A70     		strb	r2, [r3]
 554:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_slStatus |= (uint8)  I2CS_I2C_SSTAT_WR_CMPLT;
 349              		.loc 1 554 0
 350 0200 614B     		ldr	r3, .L38+20
 351 0202 1B78     		ldrb	r3, [r3]
 352 0204 DBB2     		uxtb	r3, r3
 353 0206 1022     		mov	r2, #16
 354 0208 1343     		orr	r3, r2
 355 020a DAB2     		uxtb	r2, r3
 356 020c 5E4B     		ldr	r3, .L38+20
 357 020e 1A70     		strb	r2, [r3]
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 17


 555:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_state     =  I2CS_I2C_FSM_IDLE;
 358              		.loc 1 555 0
 359 0210 5B4B     		ldr	r3, .L38+12
 360 0212 1022     		mov	r2, #16
 361 0214 1A70     		strb	r2, [r3]
 362              	.L14:
 556:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             }
 557:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 558:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 559:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             /* INTR_SLAVE_I2C_ADDR_MATCH or INTR_SLAVE_I2C_GENERAL:
 560:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * The address match or general call address event starts the slave operation:
 561:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * after leaving the TX or RX direction has to be chosen.
 562:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * The wakeup interrupt must be cleared only after an address match is set.
 563:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             */
 564:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         #if (I2CS_I2C_CUSTOM_ADDRESS_HANDLER_CONST)
 565:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             if (I2CS_CHECK_INTR_SLAVE_MASKED(I2CS_INTR_SLAVE_I2C_ADDR_MATCH |
 566:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                                          I2CS_INTR_SLAVE_I2C_GENERAL))
 567:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         #else
 568:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             if (I2CS_CHECK_INTR_SLAVE_MASKED(I2CS_INTR_SLAVE_I2C_ADDR_MATCH))
 363              		.loc 1 568 0
 364 0216 5B4B     		ldr	r3, .L38+16
 365 0218 1B68     		ldr	r3, [r3]
 366 021a 4022     		mov	r2, #64
 367 021c 1340     		and	r3, r2
 368 021e 4DD0     		beq	.L19
 569:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         #endif /* (I2CS_I2C_CUSTOM_ADDRESS_HANDLER_CONST) */
 570:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             {
 571:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 /* Clear externally clocked address match interrupt source when internally clocked 
 572:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_ClearI2CExtClkInterruptSource(I2CS_INTR_I2C_EC_WAKE_UP);
 369              		.loc 1 572 0
 370 0220 6B4B     		ldr	r3, .L38+92
 371 0222 0122     		mov	r2, #1
 372 0224 1A60     		str	r2, [r3]
 573:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 574:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 #if (I2CS_I2C_CUSTOM_ADDRESS_HANDLER)
 575:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 576:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     if (NULL != I2CS_customAddressHandler)
 577:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 578:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* Call custom address handler */
 579:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         response = I2CS_customAddressHandler();
 580:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 581:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     else
 582:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 583:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* Read address from the RX FIFO. If there is no address underflow triggers
 584:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         * component does not use that source. */
 585:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         (void) I2CS_RX_FIFO_RD_REG;
 586:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         response = I2CS_I2C_ACK_ADDR;
 587:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 588:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 589:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* Clears RX sources after address was received in the RX FIFO */
 590:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_ClearRxInterruptSource(I2CS_INTR_RX_ALL);
 591:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 592:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 #endif
 593:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 594:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             #if (I2CS_I2C_CUSTOM_ADDRESS_HANDLER_CONST)
 595:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 if (response == I2CS_I2C_NAK_ADDR)
 596:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 18


 597:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 #if (!I2CS_CY_SCBIP_V0)
 598:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* Disable write stop interrupt source as it triggers after address was NACKed.
 599:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_DISABLE_INTR_SLAVE(I2CS_INTR_SLAVE_I2C_WRITE_STOP);
 600:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 #endif /* (!I2CS_CY_SCBIP_V0) */
 601:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 602:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* Clear address match and stop history */
 603:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_ClearSlaveInterruptSource(I2CS_INTR_SLAVE_ALL);
 604:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 605:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* ACK the address byte */
 606:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_I2C_SLAVE_GENERATE_NACK;
 607:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 608:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 else
 609:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             #endif /* (I2CS_I2C_CUSTOM_ADDRESS_HANDLER_CONST) */
 610:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 611:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     if(I2CS_CHECK_I2C_STATUS(I2CS_I2C_STATUS_S_READ))
 373              		.loc 1 611 0
 374 0226 6B4B     		ldr	r3, .L38+96
 375 0228 1B68     		ldr	r3, [r3]
 376 022a 1022     		mov	r2, #16
 377 022c 1340     		and	r3, r2
 378 022e 12D0     		beq	.L20
 612:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* TX direction: master reads from slave */
 613:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 614:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_SetTxInterruptMode(I2CS_INTR_TX_EMPTY);
 379              		.loc 1 614 0
 380 0230 5B4B     		ldr	r3, .L38+44
 381 0232 1022     		mov	r2, #16
 382 0234 1A60     		str	r2, [r3]
 615:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 616:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* Set temporary index to address buffer clear from API */
 617:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_slRdBufIndexTmp = I2CS_slRdBufIndex;
 383              		.loc 1 617 0
 384 0236 594B     		ldr	r3, .L38+40
 385 0238 1A68     		ldr	r2, [r3]
 386 023a 574B     		ldr	r3, .L38+36
 387 023c 1A60     		str	r2, [r3]
 618:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 619:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* Start master reading */
 620:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_slStatus |= (uint8) I2CS_I2C_SSTAT_RD_BUSY;
 388              		.loc 1 620 0
 389 023e 524B     		ldr	r3, .L38+20
 390 0240 1B78     		ldrb	r3, [r3]
 391 0242 DBB2     		uxtb	r3, r3
 392 0244 0222     		mov	r2, #2
 393 0246 1343     		orr	r3, r2
 394 0248 DAB2     		uxtb	r2, r3
 395 024a 4F4B     		ldr	r3, .L38+20
 396 024c 1A70     		strb	r2, [r3]
 621:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_state     = I2CS_I2C_FSM_SL_RD;
 397              		.loc 1 621 0
 398 024e 4C4B     		ldr	r3, .L38+12
 399 0250 1222     		mov	r2, #18
 400 0252 1A70     		strb	r2, [r3]
 401 0254 2CE0     		b	.L21
 402              	.L20:
 622:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 623:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     else
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 19


 624:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* RX direction: master writes into slave */
 625:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 626:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* Calculate available buffer size */
 627:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         diffCount = (I2CS_slWrBufSize - I2CS_slWrBufIndex);
 403              		.loc 1 627 0
 404 0256 604B     		ldr	r3, .L38+100
 405 0258 1A68     		ldr	r2, [r3]
 406 025a 564B     		ldr	r3, .L38+64
 407 025c 1B68     		ldr	r3, [r3]
 408 025e D31A     		sub	r3, r2, r3
 409 0260 7B60     		str	r3, [r7, #4]
 628:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 629:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     #if (I2CS_CY_SCBIP_V0)
 630:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         if(diffCount < I2CS_I2C_FIFO_SIZE)
 410              		.loc 1 630 0
 411 0262 7B68     		ldr	r3, [r7, #4]
 412 0264 072B     		cmp	r3, #7
 413 0266 03D8     		bhi	.L22
 631:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* Receive data: byte-by-byte */
 632:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 633:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_SetRxInterruptMode(I2CS_INTR_RX_NOT_EMPTY);
 414              		.loc 1 633 0
 415 0268 574B     		ldr	r3, .L38+84
 416 026a 0422     		mov	r2, #4
 417 026c 1A60     		str	r2, [r3]
 418 026e 14E0     		b	.L23
 419              	.L22:
 634:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 635:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         else
 636:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* Receive data: into RX FIFO */
 637:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 638:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             if(diffCount == I2CS_I2C_FIFO_SIZE)
 420              		.loc 1 638 0
 421 0270 7B68     		ldr	r3, [r7, #4]
 422 0272 082B     		cmp	r3, #8
 423 0274 07D1     		bne	.L24
 639:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             {
 640:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 /* NACK when RX FIFO become FULL */
 641:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 I2CS_ENABLE_SLAVE_AUTO_DATA;
 424              		.loc 1 641 0
 425 0276 4D4B     		ldr	r3, .L38+56
 426 0278 4C4A     		ldr	r2, .L38+56
 427 027a 1268     		ldr	r2, [r2]
 428 027c A021     		mov	r1, #160
 429 027e 0902     		lsl	r1, r1, #8
 430 0280 0A43     		orr	r2, r1
 431 0282 1A60     		str	r2, [r3]
 432 0284 09E0     		b	.L23
 433              	.L24:
 642:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             }
 643:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             else
 644:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             {
 645:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 /* Stretch clock when RX FIFO becomes FULL */
 646:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 I2CS_ENABLE_SLAVE_AUTO_DATA_ACK;
 434              		.loc 1 646 0
 435 0286 494B     		ldr	r3, .L38+56
 436 0288 484A     		ldr	r2, .L38+56
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 20


 437 028a 1268     		ldr	r2, [r2]
 438 028c 8021     		mov	r1, #128
 439 028e 8901     		lsl	r1, r1, #6
 440 0290 0A43     		orr	r2, r1
 441 0292 1A60     		str	r2, [r3]
 647:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 I2CS_SetRxInterruptMode(I2CS_INTR_RX_FULL);
 442              		.loc 1 647 0
 443 0294 4C4B     		ldr	r3, .L38+84
 444 0296 0822     		mov	r2, #8
 445 0298 1A60     		str	r2, [r3]
 446              	.L23:
 648:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             }
 649:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 650:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 651:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     #else
 652:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         #if(I2CS_CHECK_I2C_ACCEPT_ADDRESS)
 653:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 654:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Enable RX.NOT_EMPTY interrupt source to receive byte by byte.
 655:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             * The byte by byte receive is always chosen for the case when an addres
 656:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             * in RX FIFO. Ticket ID#175559.
 657:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             */
 658:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_SetRxInterruptMode(I2CS_INTR_RX_NOT_EMPTY);
 659:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 660:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         #else
 661:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 662:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             if(diffCount < I2CS_I2C_FIFO_SIZE)
 663:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Receive data: byte-by-byte */
 664:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             {
 665:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 I2CS_SetRxInterruptMode(I2CS_INTR_RX_NOT_EMPTY);
 666:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             }
 667:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             else
 668:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Receive data: into RX FIFO */
 669:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             {
 670:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 if(diffCount == I2CS_I2C_FIFO_SIZE)
 671:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 {
 672:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     /* NACK when RX FIFO become FULL */
 673:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     I2CS_ENABLE_SLAVE_AUTO_DATA;
 674:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 }
 675:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 else
 676:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 {
 677:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     /* Stretch clock when RX FIFO becomes FULL */
 678:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     I2CS_ENABLE_SLAVE_AUTO_DATA_ACK;
 679:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                     I2CS_SetRxInterruptMode(I2CS_INTR_RX_FULL);
 680:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                                 }
 681:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             }
 682:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 683:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         #endif
 684:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     #endif /* (I2CS_CY_SCBIP_V0) */
 685:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 686:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         /* Start master reading */
 687:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_slStatus |= (uint8) I2CS_I2C_SSTAT_WR_BUSY;
 447              		.loc 1 687 0
 448 029a 3B4B     		ldr	r3, .L38+20
 449 029c 1B78     		ldrb	r3, [r3]
 450 029e DBB2     		uxtb	r3, r3
 451 02a0 2022     		mov	r2, #32
 452 02a2 1343     		orr	r3, r2
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 21


 453 02a4 DAB2     		uxtb	r2, r3
 454 02a6 384B     		ldr	r3, .L38+20
 455 02a8 1A70     		strb	r2, [r3]
 688:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_state     = I2CS_I2C_FSM_SL_WR;
 456              		.loc 1 688 0
 457 02aa 354B     		ldr	r3, .L38+12
 458 02ac 1122     		mov	r2, #17
 459 02ae 1A70     		strb	r2, [r3]
 460              	.L21:
 689:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 690:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 691:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* Clear address match and stop history */
 692:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_ClearSlaveInterruptSource(I2CS_INTR_SLAVE_ALL);
 461              		.loc 1 692 0
 462 02b0 364B     		ldr	r3, .L38+24
 463 02b2 4A4A     		ldr	r2, .L38+104
 464 02b4 1A60     		str	r2, [r3]
 693:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 694:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 #if (!I2CS_CY_SCBIP_V0)
 695:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* Enable write stop interrupt source as it triggers after address was NACKed. 
 696:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_ENABLE_INTR_SLAVE(I2CS_INTR_SLAVE_I2C_WRITE_STOP);
 697:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 #endif /* (!I2CS_CY_SCBIP_V0) */
 698:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 699:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* ACK the address byte */
 700:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_I2C_SLAVE_GENERATE_ACK;
 465              		.loc 1 700 0
 466 02b6 4A4B     		ldr	r3, .L38+108
 467 02b8 0122     		mov	r2, #1
 468 02ba 1A60     		str	r2, [r3]
 469              	.L19:
 701:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 702:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             }
 703:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 704:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             /* I2CS_INTR_RX_FULL:
 705:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * Get data from the RX FIFO and decide whether to ACK or NACK the following bytes
 706:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             */
 707:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             if(I2CS_CHECK_INTR_RX_MASKED(I2CS_INTR_RX_FULL))
 470              		.loc 1 707 0
 471 02bc 494B     		ldr	r3, .L38+112
 472 02be 1B68     		ldr	r3, [r3]
 473 02c0 0822     		mov	r2, #8
 474 02c2 1340     		and	r3, r2
 475 02c4 36D0     		beq	.L25
 708:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             {
 709:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 /* Calculate available buffer size to take into account that RX FIFO is FULL */
 710:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 diffCount =  I2CS_slWrBufSize -
 476              		.loc 1 710 0
 477 02c6 444B     		ldr	r3, .L38+100
 478 02c8 1A68     		ldr	r2, [r3]
 479 02ca 3A4B     		ldr	r3, .L38+64
 480 02cc 1B68     		ldr	r3, [r3]
 481 02ce D31A     		sub	r3, r2, r3
 482 02d0 083B     		sub	r3, r3, #8
 483 02d2 7B60     		str	r3, [r7, #4]
 711:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             (I2CS_slWrBufIndex + I2CS_I2C_FIFO_SIZE);
 712:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 713:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 if(diffCount > I2CS_I2C_FIFO_SIZE) /* Proceed transaction */
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 22


 484              		.loc 1 713 0
 485 02d4 7B68     		ldr	r3, [r7, #4]
 486 02d6 082B     		cmp	r3, #8
 487 02d8 04D9     		bls	.L26
 714:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 715:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     diffCount   = I2CS_I2C_FIFO_SIZE;
 488              		.loc 1 715 0
 489 02da 0823     		mov	r3, #8
 490 02dc 7B60     		str	r3, [r7, #4]
 716:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     endTransfer = 0u;  /* Continue active transfer */
 491              		.loc 1 716 0
 492 02de 0023     		mov	r3, #0
 493 02e0 3B60     		str	r3, [r7]
 494 02e2 01E0     		b	.L27
 495              	.L26:
 717:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 718:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 else /* End when FIFO becomes FULL again */
 719:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 720:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     endTransfer = I2CS_I2C_CMPLT_ANY_TRANSFER;
 496              		.loc 1 720 0
 497 02e4 0123     		mov	r3, #1
 498 02e6 3B60     		str	r3, [r7]
 499              	.L27:
 721:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 722:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 723:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 for(; (0u != diffCount); diffCount--)
 500              		.loc 1 723 0
 501 02e8 10E0     		b	.L28
 502              	.L29:
 724:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 725:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* Put data in component buffer */
 726:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_slWrBufPtr[I2CS_slWrBufIndex] = (uint8) I2CS_RX_FIFO_RD_REG;
 503              		.loc 1 726 0 discriminator 2
 504 02ea 314B     		ldr	r3, .L38+60
 505 02ec 1A68     		ldr	r2, [r3]
 506 02ee 314B     		ldr	r3, .L38+64
 507 02f0 1B68     		ldr	r3, [r3]
 508 02f2 D218     		add	r2, r2, r3
 509 02f4 304B     		ldr	r3, .L38+68
 510 02f6 1B68     		ldr	r3, [r3]
 511 02f8 DBB2     		uxtb	r3, r3
 512 02fa 1370     		strb	r3, [r2]
 727:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_slWrBufIndex++;
 513              		.loc 1 727 0 discriminator 2
 514 02fc 2D4B     		ldr	r3, .L38+64
 515 02fe 1B68     		ldr	r3, [r3]
 516 0300 5A1C     		add	r2, r3, #1
 517 0302 2C4B     		ldr	r3, .L38+64
 518 0304 1A60     		str	r2, [r3]
 723:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 519              		.loc 1 723 0 discriminator 2
 520 0306 7B68     		ldr	r3, [r7, #4]
 521 0308 013B     		sub	r3, r3, #1
 522 030a 7B60     		str	r3, [r7, #4]
 523              	.L28:
 723:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 524              		.loc 1 723 0 is_stmt 0 discriminator 1
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 23


 525 030c 7B68     		ldr	r3, [r7, #4]
 526 030e 002B     		cmp	r3, #0
 527 0310 EBD1     		bne	.L29
 728:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 729:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 730:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 if(0u != endTransfer) /* End transfer sending NACK */
 528              		.loc 1 730 0 is_stmt 1
 529 0312 3B68     		ldr	r3, [r7]
 530 0314 002B     		cmp	r3, #0
 531 0316 09D0     		beq	.L30
 731:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 732:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_ENABLE_SLAVE_AUTO_DATA_NACK;
 532              		.loc 1 732 0
 533 0318 244B     		ldr	r3, .L38+56
 534 031a 244A     		ldr	r2, .L38+56
 535 031c 1268     		ldr	r2, [r2]
 536 031e 8021     		mov	r1, #128
 537 0320 0902     		lsl	r1, r1, #8
 538 0322 0A43     		orr	r2, r1
 539 0324 1A60     		str	r2, [r3]
 733:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 734:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* INTR_RX_FULL triggers earlier than INTR_SLAVE_I2C_STOP:
 735:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     * disable all RX interrupt sources.
 736:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     */
 737:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_SetRxInterruptMode(I2CS_NO_INTR_SOURCES);
 540              		.loc 1 737 0
 541 0326 284B     		ldr	r3, .L38+84
 542 0328 0022     		mov	r2, #0
 543 032a 1A60     		str	r2, [r3]
 544              	.L30:
 738:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 739:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 740:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_ClearRxInterruptSource(I2CS_INTR_RX_FULL);
 545              		.loc 1 740 0
 546 032c 254B     		ldr	r3, .L38+80
 547 032e 0822     		mov	r2, #8
 548 0330 1A60     		str	r2, [r3]
 549 0332 66E0     		b	.L31
 550              	.L25:
 741:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             }
 742:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             /* I2CS_INTR_RX_NOT_EMPTY:
 743:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * The buffer size is less than 8: it requires processing in byte-by-byte mode.
 744:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             */
 745:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             else if(I2CS_CHECK_INTR_RX_MASKED(I2CS_INTR_RX_NOT_EMPTY))
 551              		.loc 1 745 0
 552 0334 2B4B     		ldr	r3, .L38+112
 553 0336 1B68     		ldr	r3, [r3]
 554 0338 0422     		mov	r2, #4
 555 033a 1340     		and	r3, r2
 556 033c 61D0     		beq	.L31
 746:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             {
 747:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 diffCount = I2CS_RX_FIFO_RD_REG;
 557              		.loc 1 747 0
 558 033e 1E4B     		ldr	r3, .L38+68
 559 0340 1B68     		ldr	r3, [r3]
 560 0342 7B60     		str	r3, [r7, #4]
 748:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 24


 749:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 if(I2CS_slWrBufIndex < I2CS_slWrBufSize)
 561              		.loc 1 749 0
 562 0344 1B4B     		ldr	r3, .L38+64
 563 0346 1A68     		ldr	r2, [r3]
 564 0348 234B     		ldr	r3, .L38+100
 565 034a 1B68     		ldr	r3, [r3]
 566 034c 9A42     		cmp	r2, r3
 567 034e 4BD2     		bcs	.L32
 750:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 751:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_I2C_SLAVE_GENERATE_ACK;
 568              		.loc 1 751 0
 569 0350 234B     		ldr	r3, .L38+108
 570 0352 0122     		mov	r2, #1
 571 0354 1A60     		str	r2, [r3]
 752:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 753:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* Put data into component buffer */
 754:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_slWrBufPtr[I2CS_slWrBufIndex] = (uint8) diffCount;
 572              		.loc 1 754 0
 573 0356 164B     		ldr	r3, .L38+60
 574 0358 1A68     		ldr	r2, [r3]
 575 035a 164B     		ldr	r3, .L38+64
 576 035c 1B68     		ldr	r3, [r3]
 577 035e D318     		add	r3, r2, r3
 578 0360 7A68     		ldr	r2, [r7, #4]
 579 0362 D2B2     		uxtb	r2, r2
 580 0364 1A70     		strb	r2, [r3]
 755:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_slWrBufIndex++;
 581              		.loc 1 755 0
 582 0366 134B     		ldr	r3, .L38+64
 583 0368 1B68     		ldr	r3, [r3]
 584 036a 5A1C     		add	r2, r3, #1
 585 036c 114B     		ldr	r3, .L38+64
 586 036e 1A60     		str	r2, [r3]
 587 0370 44E0     		b	.L33
 588              	.L39:
 589 0372 C046     		.align	2
 590              	.L38:
 591 0374 00000000 		.word	I2CS_customIntrHandler
 592 0378 8C0E0740 		.word	1074204300
 593 037c 880E0740 		.word	1074204296
 594 0380 00000000 		.word	I2CS_state
 595 0384 4C0F0740 		.word	1074204492
 596 0388 00000000 		.word	I2CS_slStatus
 597 038c 400F0740 		.word	1074204480
 598 0390 08020740 		.word	1074201096
 599 0394 00000000 		.word	I2CS_slOverFlowCount
 600 0398 00000000 		.word	I2CS_slRdBufIndexTmp
 601 039c 00000000 		.word	I2CS_slRdBufIndex
 602 03a0 880F0740 		.word	1074204552
 603 03a4 04020740 		.word	1074201092
 604 03a8 FFFFFEFF 		.word	-65537
 605 03ac 60000740 		.word	1074200672
 606 03b0 00000000 		.word	I2CS_slWrBufPtr
 607 03b4 00000000 		.word	I2CS_slWrBufIndex
 608 03b8 40030740 		.word	1074201408
 609 03bc 08030740 		.word	1074201352
 610 03c0 FF5FFFFF 		.word	-40961
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 25


 611 03c4 C00F0740 		.word	1074204608
 612 03c8 C80F0740 		.word	1074204616
 613 03cc ED0F0000 		.word	4077
 614 03d0 800E0740 		.word	1074204288
 615 03d4 64000740 		.word	1074200676
 616 03d8 00000000 		.word	I2CS_slWrBufSize
 617 03dc FF0F0000 		.word	4095
 618 03e0 6C000740 		.word	1074200684
 619 03e4 CC0F0740 		.word	1074204620
 620              	.L32:
 756:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 757:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 else /* Overflow: there is no space in write buffer */
 758:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 759:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_I2C_SLAVE_GENERATE_NACK;
 621              		.loc 1 759 0
 622 03e8 FFF7FEFF 		bl	I2CS_I2CSlaveNackGeneration
 760:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 761:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     I2CS_slStatus |= (uint8) I2CS_I2C_SSTAT_WR_OVFL;
 623              		.loc 1 761 0
 624 03ec 374B     		ldr	r3, .L40
 625 03ee 1B78     		ldrb	r3, [r3]
 626 03f0 DBB2     		uxtb	r3, r3
 627 03f2 4022     		mov	r2, #64
 628 03f4 1343     		orr	r3, r2
 629 03f6 DAB2     		uxtb	r2, r3
 630 03f8 344B     		ldr	r3, .L40
 631 03fa 1A70     		strb	r2, [r3]
 632              	.L33:
 762:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 763:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 764:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_ClearRxInterruptSource(I2CS_INTR_RX_NOT_EMPTY);
 633              		.loc 1 764 0
 634 03fc 344B     		ldr	r3, .L40+4
 635 03fe 0422     		mov	r2, #4
 636 0400 1A60     		str	r2, [r3]
 637              	.L31:
 765:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             }
 766:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             else
 767:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             {
 768:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 /* Does nothing */
 769:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             }
 770:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 771:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 772:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             /* I2CS_INTR_TX_EMPTY:
 773:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * The master reads the slave: provide data to read or 0xFF in the case of the end of th
 774:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * The overflow condition must be captured, but not set until the end of transaction.
 775:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             * There is a possibility of a false overflow due to TX FIFO utilization.
 776:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             */
 777:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             if(I2CS_CHECK_INTR_TX_MASKED(I2CS_INTR_TX_EMPTY))
 638              		.loc 1 777 0
 639 0402 344B     		ldr	r3, .L40+8
 640 0404 1B68     		ldr	r3, [r3]
 641 0406 1022     		mov	r2, #16
 642 0408 1340     		and	r3, r2
 643 040a 5CD0     		beq	.L1
 778:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             {
 779:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 while(I2CS_I2C_FIFO_SIZE != I2CS_GET_TX_FIFO_ENTRIES)
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 26


 644              		.loc 1 779 0
 645 040c 23E0     		b	.L35
 646              	.L37:
 780:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 781:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* Temporary slRdBufIndexTmp is used because the master can NACK the byte and
 782:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     * index roll-back is required in this case. The slRdBufIndex is updated at the 
 783:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     * of the read transfer.
 784:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     */
 785:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     if(I2CS_slRdBufIndexTmp < I2CS_slRdBufSize)
 647              		.loc 1 785 0
 648 040e 324B     		ldr	r3, .L40+12
 649 0410 1A68     		ldr	r2, [r3]
 650 0412 324B     		ldr	r3, .L40+16
 651 0414 1B68     		ldr	r3, [r3]
 652 0416 9A42     		cmp	r2, r3
 653 0418 0ED2     		bcs	.L36
 786:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* Data from buffer */
 787:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 788:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_TX_FIFO_WR_REG = (uint32) I2CS_slRdBufPtr[I2CS_slRdBufIndexTmp];
 654              		.loc 1 788 0
 655 041a 314A     		ldr	r2, .L40+20
 656 041c 314B     		ldr	r3, .L40+24
 657 041e 1968     		ldr	r1, [r3]
 658 0420 2D4B     		ldr	r3, .L40+12
 659 0422 1B68     		ldr	r3, [r3]
 660 0424 CB18     		add	r3, r1, r3
 661 0426 1B78     		ldrb	r3, [r3]
 662 0428 DBB2     		uxtb	r3, r3
 663 042a 1360     		str	r3, [r2]
 789:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_slRdBufIndexTmp++;
 664              		.loc 1 789 0
 665 042c 2A4B     		ldr	r3, .L40+12
 666 042e 1B68     		ldr	r3, [r3]
 667 0430 5A1C     		add	r2, r3, #1
 668 0432 294B     		ldr	r3, .L40+12
 669 0434 1A60     		str	r2, [r3]
 670 0436 0EE0     		b	.L35
 671              	.L36:
 790:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 791:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     else
 792:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     /* Probably Overflow */
 793:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     {
 794:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         I2CS_TX_FIFO_WR_REG = I2CS_I2C_SLAVE_OVFL_RETURN;
 672              		.loc 1 794 0
 673 0438 294B     		ldr	r3, .L40+20
 674 043a FF22     		mov	r2, #255
 675 043c 1A60     		str	r2, [r3]
 795:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 796:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         if(I2CS_slOverFlowCount <= I2CS_I2C_TX_OVERFLOW_COUNT)
 676              		.loc 1 796 0
 677 043e 2A4B     		ldr	r3, .L40+28
 678 0440 1B78     		ldrb	r3, [r3]
 679 0442 DBB2     		uxtb	r3, r3
 680 0444 0A2B     		cmp	r3, #10
 681 0446 06D8     		bhi	.L35
 797:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         {
 798:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             /* Get counter in range of overflow. */
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 27


 799:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                             I2CS_slOverFlowCount++;
 682              		.loc 1 799 0
 683 0448 274B     		ldr	r3, .L40+28
 684 044a 1B78     		ldrb	r3, [r3]
 685 044c DBB2     		uxtb	r3, r3
 686 044e 0133     		add	r3, r3, #1
 687 0450 DAB2     		uxtb	r2, r3
 688 0452 254B     		ldr	r3, .L40+28
 689 0454 1A70     		strb	r2, [r3]
 690              	.L35:
 779:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 {
 691              		.loc 1 779 0
 692 0456 254B     		ldr	r3, .L40+32
 693 0458 1B68     		ldr	r3, [r3]
 694 045a 0F22     		mov	r2, #15
 695 045c 1340     		and	r3, r2
 696 045e 082B     		cmp	r3, #8
 697 0460 D5D1     		bne	.L37
 800:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                         }
 801:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                     }
 802:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 }
 803:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 804:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****                 I2CS_ClearTxInterruptSource(I2CS_INTR_TX_EMPTY);
 698              		.loc 1 804 0
 699 0462 234B     		ldr	r3, .L40+36
 700 0464 1022     		mov	r2, #16
 701 0466 1A60     		str	r2, [r3]
 702 0468 2DE0     		b	.L1
 703              	.L8:
 805:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****             }
 806:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 807:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         }  /* (I2CS_I2C_SLAVE) */
 808:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         #endif
 809:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     }
 810:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 811:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 812:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     /* FSM EXIT:
 813:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     * Slave:  INTR_SLAVE_I2C_BUS_ERROR, INTR_SLAVE_I2C_ARB_LOST
 814:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     * Master: INTR_MASTER_I2C_BUS_ERROR, INTR_MASTER_I2C_ARB_LOST.
 815:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     */
 816:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     else
 817:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     {
 818:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         I2CS_CTRL_REG &= (uint32) ~I2CS_CTRL_ENABLED; /* Disable scb IP */
 704              		.loc 1 818 0
 705 046a 224B     		ldr	r3, .L40+40
 706 046c 214A     		ldr	r2, .L40+40
 707 046e 1268     		ldr	r2, [r2]
 708 0470 5200     		lsl	r2, r2, #1
 709 0472 5208     		lsr	r2, r2, #1
 710 0474 1A60     		str	r2, [r3]
 819:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 820:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         I2CS_state = I2CS_I2C_FSM_IDLE;
 711              		.loc 1 820 0
 712 0476 204B     		ldr	r3, .L40+44
 713 0478 1022     		mov	r2, #16
 714 047a 1A70     		strb	r2, [r3]
 821:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 28


 822:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         I2CS_DISABLE_SLAVE_AUTO_DATA;
 715              		.loc 1 822 0
 716 047c 1F4B     		ldr	r3, .L40+48
 717 047e 1F4A     		ldr	r2, .L40+48
 718 0480 1268     		ldr	r2, [r2]
 719 0482 1F49     		ldr	r1, .L40+52
 720 0484 0A40     		and	r2, r1
 721 0486 1A60     		str	r2, [r3]
 823:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         I2CS_DISABLE_MASTER_AUTO_DATA;
 722              		.loc 1 823 0
 723 0488 1C4B     		ldr	r3, .L40+48
 724 048a 1C4A     		ldr	r2, .L40+48
 725 048c 1268     		ldr	r2, [r2]
 726 048e 1D49     		ldr	r1, .L40+56
 727 0490 0A40     		and	r2, r1
 728 0492 1A60     		str	r2, [r3]
 824:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 825:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     #if(I2CS_CY_SCBIP_V0)
 826:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         I2CS_SetRxInterruptMode(I2CS_NO_INTR_SOURCES);
 729              		.loc 1 826 0
 730 0494 1C4B     		ldr	r3, .L40+60
 731 0496 0022     		mov	r2, #0
 732 0498 1A60     		str	r2, [r3]
 827:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         I2CS_SetTxInterruptMode(I2CS_NO_INTR_SOURCES);
 733              		.loc 1 827 0
 734 049a 1C4B     		ldr	r3, .L40+64
 735 049c 0022     		mov	r2, #0
 736 049e 1A60     		str	r2, [r3]
 828:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 829:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         /* Clear interrupt sources as they are not automatically cleared after SCB is disabled */
 830:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         I2CS_ClearTxInterruptSource(I2CS_INTR_RX_ALL);
 737              		.loc 1 830 0
 738 04a0 134B     		ldr	r3, .L40+36
 739 04a2 1B4A     		ldr	r2, .L40+68
 740 04a4 1A60     		str	r2, [r3]
 831:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         I2CS_ClearRxInterruptSource(I2CS_INTR_TX_ALL);
 741              		.loc 1 831 0
 742 04a6 0A4B     		ldr	r3, .L40+4
 743 04a8 1A4A     		ldr	r2, .L40+72
 744 04aa 1A60     		str	r2, [r3]
 832:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         I2CS_ClearSlaveInterruptSource(I2CS_INTR_SLAVE_ALL);
 745              		.loc 1 832 0
 746 04ac 1A4B     		ldr	r3, .L40+76
 747 04ae 1B4A     		ldr	r2, .L40+80
 748 04b0 1A60     		str	r2, [r3]
 833:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         I2CS_ClearMasterInterruptSource(I2CS_INTR_MASTER_ALL);
 749              		.loc 1 833 0
 750 04b2 1B4B     		ldr	r3, .L40+84
 751 04b4 1B4A     		ldr	r2, .L40+88
 752 04b6 1A60     		str	r2, [r3]
 834:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     #endif /* (I2CS_CY_SCBIP_V0) */
 835:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 836:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****         I2CS_CTRL_REG |= (uint32) I2CS_CTRL_ENABLED;  /* Enable scb IP */
 753              		.loc 1 836 0
 754 04b8 0E4B     		ldr	r3, .L40+40
 755 04ba 0E4A     		ldr	r2, .L40+40
 756 04bc 1268     		ldr	r2, [r2]
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 29


 757 04be 8021     		mov	r1, #128
 758 04c0 0906     		lsl	r1, r1, #24
 759 04c2 0A43     		orr	r2, r1
 760 04c4 1A60     		str	r2, [r3]
 761              	.L1:
 837:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     }
 838:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 839:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** #ifdef I2CS_I2C_ISR_EXIT_CALLBACK
 840:.\Generated_Source\PSoC4/I2CS_I2C_INT.c ****     I2CS_I2C_ISR_ExitCallback();
 841:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** #endif /* I2CS_I2C_ISR_EXIT_CALLBACK */
 842:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** 
 843:.\Generated_Source\PSoC4/I2CS_I2C_INT.c **** }
 762              		.loc 1 843 0
 763 04c6 BD46     		mov	sp, r7
 764 04c8 02B0     		add	sp, sp, #8
 765              		@ sp needed
 766 04ca 80BD     		pop	{r7, pc}
 767              	.L41:
 768              		.align	2
 769              	.L40:
 770 04cc 00000000 		.word	I2CS_slStatus
 771 04d0 C00F0740 		.word	1074204608
 772 04d4 8C0F0740 		.word	1074204556
 773 04d8 00000000 		.word	I2CS_slRdBufIndexTmp
 774 04dc 00000000 		.word	I2CS_slRdBufSize
 775 04e0 40020740 		.word	1074201152
 776 04e4 00000000 		.word	I2CS_slRdBufPtr
 777 04e8 00000000 		.word	I2CS_slOverFlowCount
 778 04ec 08020740 		.word	1074201096
 779 04f0 800F0740 		.word	1074204544
 780 04f4 00000740 		.word	1074200576
 781 04f8 00000000 		.word	I2CS_state
 782 04fc 60000740 		.word	1074200672
 783 0500 FF5FFFFF 		.word	-40961
 784 0504 FFFCFFFF 		.word	-769
 785 0508 C80F0740 		.word	1074204616
 786 050c 880F0740 		.word	1074204552
 787 0510 ED0F0000 		.word	4077
 788 0514 F3070000 		.word	2035
 789 0518 400F0740 		.word	1074204480
 790 051c FF0F0000 		.word	4095
 791 0520 000F0740 		.word	1074204416
 792 0524 17030000 		.word	791
 793              		.cfi_endproc
 794              	.LFE0:
 795              		.size	I2CS_I2C_ISR, .-I2CS_I2C_ISR
 796              		.text
 797              	.Letext0:
 798              		.file 2 "Generated_Source\\PSoC4/cytypes.h"
 799              		.file 3 ".\\Generated_Source\\PSoC4\\I2CS_PVT.h"
 800              		.file 4 ".\\Generated_Source\\PSoC4\\I2CS_I2C_PVT.h"
 801              		.section	.debug_info,"",%progbits
 802              	.Ldebug_info0:
 803 0000 76010000 		.4byte	0x176
 804 0004 0400     		.2byte	0x4
 805 0006 00000000 		.4byte	.Ldebug_abbrev0
 806 000a 04       		.byte	0x4
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 30


 807 000b 01       		.uleb128 0x1
 808 000c A7000000 		.4byte	.LASF30
 809 0010 01       		.byte	0x1
 810 0011 3C010000 		.4byte	.LASF31
 811 0015 58020000 		.4byte	.LASF32
 812 0019 00000000 		.4byte	.Ldebug_ranges0+0
 813 001d 00000000 		.4byte	0
 814 0021 00000000 		.4byte	.Ldebug_line0
 815 0025 02       		.uleb128 0x2
 816 0026 01       		.byte	0x1
 817 0027 06       		.byte	0x6
 818 0028 3B020000 		.4byte	.LASF0
 819 002c 02       		.uleb128 0x2
 820 002d 01       		.byte	0x1
 821 002e 08       		.byte	0x8
 822 002f 4E000000 		.4byte	.LASF1
 823 0033 02       		.uleb128 0x2
 824 0034 02       		.byte	0x2
 825 0035 05       		.byte	0x5
 826 0036 01020000 		.4byte	.LASF2
 827 003a 02       		.uleb128 0x2
 828 003b 02       		.byte	0x2
 829 003c 07       		.byte	0x7
 830 003d 29000000 		.4byte	.LASF3
 831 0041 02       		.uleb128 0x2
 832 0042 04       		.byte	0x4
 833 0043 05       		.byte	0x5
 834 0044 32020000 		.4byte	.LASF4
 835 0048 02       		.uleb128 0x2
 836 0049 04       		.byte	0x4
 837 004a 07       		.byte	0x7
 838 004b 6E000000 		.4byte	.LASF5
 839 004f 02       		.uleb128 0x2
 840 0050 08       		.byte	0x8
 841 0051 05       		.byte	0x5
 842 0052 D2010000 		.4byte	.LASF6
 843 0056 02       		.uleb128 0x2
 844 0057 08       		.byte	0x8
 845 0058 07       		.byte	0x7
 846 0059 71010000 		.4byte	.LASF7
 847 005d 03       		.uleb128 0x3
 848 005e 04       		.byte	0x4
 849 005f 05       		.byte	0x5
 850 0060 696E7400 		.ascii	"int\000"
 851 0064 02       		.uleb128 0x2
 852 0065 04       		.byte	0x4
 853 0066 07       		.byte	0x7
 854 0067 64010000 		.4byte	.LASF8
 855 006b 04       		.uleb128 0x4
 856 006c 8A000000 		.4byte	.LASF9
 857 0070 02       		.byte	0x2
 858 0071 9801     		.2byte	0x198
 859 0073 2C000000 		.4byte	0x2c
 860 0077 04       		.uleb128 0x4
 861 0078 35010000 		.4byte	.LASF10
 862 007c 02       		.byte	0x2
 863 007d 9A01     		.2byte	0x19a
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 31


 864 007f 48000000 		.4byte	0x48
 865 0083 02       		.uleb128 0x2
 866 0084 04       		.byte	0x4
 867 0085 04       		.byte	0x4
 868 0086 48000000 		.4byte	.LASF11
 869 008a 02       		.uleb128 0x2
 870 008b 08       		.byte	0x8
 871 008c 04       		.byte	0x4
 872 008d 90000000 		.4byte	.LASF12
 873 0091 02       		.uleb128 0x2
 874 0092 01       		.byte	0x1
 875 0093 08       		.byte	0x8
 876 0094 E0010000 		.4byte	.LASF13
 877 0098 05       		.uleb128 0x5
 878 0099 6B000000 		.4byte	0x6b
 879 009d 04       		.uleb128 0x4
 880 009e 0E000000 		.4byte	.LASF14
 881 00a2 02       		.byte	0x2
 882 00a3 4402     		.2byte	0x244
 883 00a5 A9000000 		.4byte	0xa9
 884 00a9 05       		.uleb128 0x5
 885 00aa 77000000 		.4byte	0x77
 886 00ae 04       		.uleb128 0x4
 887 00af 9D010000 		.4byte	.LASF15
 888 00b3 02       		.byte	0x2
 889 00b4 5402     		.2byte	0x254
 890 00b6 BA000000 		.4byte	0xba
 891 00ba 06       		.uleb128 0x6
 892 00bb 04       		.byte	0x4
 893 00bc C0000000 		.4byte	0xc0
 894 00c0 07       		.uleb128 0x7
 895 00c1 02       		.uleb128 0x2
 896 00c2 04       		.byte	0x4
 897 00c3 07       		.byte	0x7
 898 00c4 C9010000 		.4byte	.LASF16
 899 00c8 08       		.uleb128 0x8
 900 00c9 AA010000 		.4byte	.LASF33
 901 00cd 01       		.byte	0x1
 902 00ce 1F       		.byte	0x1f
 903 00cf 00000000 		.4byte	.LFB0
 904 00d3 28050000 		.4byte	.LFE0-.LFB0
 905 00d7 01       		.uleb128 0x1
 906 00d8 9C       		.byte	0x9c
 907 00d9 FA000000 		.4byte	0xfa
 908 00dd 09       		.uleb128 0x9
 909 00de 80000000 		.4byte	.LASF17
 910 00e2 01       		.byte	0x1
 911 00e3 21       		.byte	0x21
 912 00e4 77000000 		.4byte	0x77
 913 00e8 02       		.uleb128 0x2
 914 00e9 91       		.byte	0x91
 915 00ea 74       		.sleb128 -12
 916 00eb 09       		.uleb128 0x9
 917 00ec 3C000000 		.4byte	.LASF18
 918 00f0 01       		.byte	0x1
 919 00f1 22       		.byte	0x22
 920 00f2 77000000 		.4byte	0x77
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 32


 921 00f6 02       		.uleb128 0x2
 922 00f7 91       		.byte	0x91
 923 00f8 70       		.sleb128 -16
 924 00f9 00       		.byte	0
 925 00fa 0A       		.uleb128 0xa
 926 00fb 1B020000 		.4byte	.LASF19
 927 00ff 03       		.byte	0x3
 928 0100 3B       		.byte	0x3b
 929 0101 AE000000 		.4byte	0xae
 930 0105 0A       		.uleb128 0xa
 931 0106 E5010000 		.4byte	.LASF20
 932 010a 04       		.byte	0x4
 933 010b 1E       		.byte	0x1e
 934 010c 98000000 		.4byte	0x98
 935 0110 0A       		.uleb128 0xa
 936 0111 00000000 		.4byte	.LASF21
 937 0115 04       		.byte	0x4
 938 0116 21       		.byte	0x21
 939 0117 98000000 		.4byte	0x98
 940 011b 0A       		.uleb128 0xa
 941 011c 0B020000 		.4byte	.LASF22
 942 0120 04       		.byte	0x4
 943 0121 24       		.byte	0x24
 944 0122 26010000 		.4byte	0x126
 945 0126 06       		.uleb128 0x6
 946 0127 04       		.byte	0x4
 947 0128 98000000 		.4byte	0x98
 948 012c 0A       		.uleb128 0xa
 949 012d F0010000 		.4byte	.LASF23
 950 0131 04       		.byte	0x4
 951 0132 25       		.byte	0x25
 952 0133 A9000000 		.4byte	0xa9
 953 0137 0A       		.uleb128 0xa
 954 0138 5C000000 		.4byte	.LASF24
 955 013c 04       		.byte	0x4
 956 013d 26       		.byte	0x26
 957 013e A9000000 		.4byte	0xa9
 958 0142 0A       		.uleb128 0xa
 959 0143 97000000 		.4byte	.LASF25
 960 0147 04       		.byte	0x4
 961 0148 29       		.byte	0x29
 962 0149 26010000 		.4byte	0x126
 963 014d 0A       		.uleb128 0xa
 964 014e 47020000 		.4byte	.LASF26
 965 0152 04       		.byte	0x4
 966 0153 2A       		.byte	0x2a
 967 0154 A9000000 		.4byte	0xa9
 968 0158 0A       		.uleb128 0xa
 969 0159 B7010000 		.4byte	.LASF27
 970 015d 04       		.byte	0x4
 971 015e 2B       		.byte	0x2b
 972 015f A9000000 		.4byte	0xa9
 973 0163 0A       		.uleb128 0xa
 974 0164 88010000 		.4byte	.LASF28
 975 0168 04       		.byte	0x4
 976 0169 2C       		.byte	0x2c
 977 016a A9000000 		.4byte	0xa9
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 33


 978 016e 0A       		.uleb128 0xa
 979 016f 14000000 		.4byte	.LASF29
 980 0173 04       		.byte	0x4
 981 0174 2D       		.byte	0x2d
 982 0175 98000000 		.4byte	0x98
 983 0179 00       		.byte	0
 984              		.section	.debug_abbrev,"",%progbits
 985              	.Ldebug_abbrev0:
 986 0000 01       		.uleb128 0x1
 987 0001 11       		.uleb128 0x11
 988 0002 01       		.byte	0x1
 989 0003 25       		.uleb128 0x25
 990 0004 0E       		.uleb128 0xe
 991 0005 13       		.uleb128 0x13
 992 0006 0B       		.uleb128 0xb
 993 0007 03       		.uleb128 0x3
 994 0008 0E       		.uleb128 0xe
 995 0009 1B       		.uleb128 0x1b
 996 000a 0E       		.uleb128 0xe
 997 000b 55       		.uleb128 0x55
 998 000c 17       		.uleb128 0x17
 999 000d 11       		.uleb128 0x11
 1000 000e 01       		.uleb128 0x1
 1001 000f 10       		.uleb128 0x10
 1002 0010 17       		.uleb128 0x17
 1003 0011 00       		.byte	0
 1004 0012 00       		.byte	0
 1005 0013 02       		.uleb128 0x2
 1006 0014 24       		.uleb128 0x24
 1007 0015 00       		.byte	0
 1008 0016 0B       		.uleb128 0xb
 1009 0017 0B       		.uleb128 0xb
 1010 0018 3E       		.uleb128 0x3e
 1011 0019 0B       		.uleb128 0xb
 1012 001a 03       		.uleb128 0x3
 1013 001b 0E       		.uleb128 0xe
 1014 001c 00       		.byte	0
 1015 001d 00       		.byte	0
 1016 001e 03       		.uleb128 0x3
 1017 001f 24       		.uleb128 0x24
 1018 0020 00       		.byte	0
 1019 0021 0B       		.uleb128 0xb
 1020 0022 0B       		.uleb128 0xb
 1021 0023 3E       		.uleb128 0x3e
 1022 0024 0B       		.uleb128 0xb
 1023 0025 03       		.uleb128 0x3
 1024 0026 08       		.uleb128 0x8
 1025 0027 00       		.byte	0
 1026 0028 00       		.byte	0
 1027 0029 04       		.uleb128 0x4
 1028 002a 16       		.uleb128 0x16
 1029 002b 00       		.byte	0
 1030 002c 03       		.uleb128 0x3
 1031 002d 0E       		.uleb128 0xe
 1032 002e 3A       		.uleb128 0x3a
 1033 002f 0B       		.uleb128 0xb
 1034 0030 3B       		.uleb128 0x3b
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 34


 1035 0031 05       		.uleb128 0x5
 1036 0032 49       		.uleb128 0x49
 1037 0033 13       		.uleb128 0x13
 1038 0034 00       		.byte	0
 1039 0035 00       		.byte	0
 1040 0036 05       		.uleb128 0x5
 1041 0037 35       		.uleb128 0x35
 1042 0038 00       		.byte	0
 1043 0039 49       		.uleb128 0x49
 1044 003a 13       		.uleb128 0x13
 1045 003b 00       		.byte	0
 1046 003c 00       		.byte	0
 1047 003d 06       		.uleb128 0x6
 1048 003e 0F       		.uleb128 0xf
 1049 003f 00       		.byte	0
 1050 0040 0B       		.uleb128 0xb
 1051 0041 0B       		.uleb128 0xb
 1052 0042 49       		.uleb128 0x49
 1053 0043 13       		.uleb128 0x13
 1054 0044 00       		.byte	0
 1055 0045 00       		.byte	0
 1056 0046 07       		.uleb128 0x7
 1057 0047 15       		.uleb128 0x15
 1058 0048 00       		.byte	0
 1059 0049 27       		.uleb128 0x27
 1060 004a 19       		.uleb128 0x19
 1061 004b 00       		.byte	0
 1062 004c 00       		.byte	0
 1063 004d 08       		.uleb128 0x8
 1064 004e 2E       		.uleb128 0x2e
 1065 004f 01       		.byte	0x1
 1066 0050 3F       		.uleb128 0x3f
 1067 0051 19       		.uleb128 0x19
 1068 0052 03       		.uleb128 0x3
 1069 0053 0E       		.uleb128 0xe
 1070 0054 3A       		.uleb128 0x3a
 1071 0055 0B       		.uleb128 0xb
 1072 0056 3B       		.uleb128 0x3b
 1073 0057 0B       		.uleb128 0xb
 1074 0058 27       		.uleb128 0x27
 1075 0059 19       		.uleb128 0x19
 1076 005a 11       		.uleb128 0x11
 1077 005b 01       		.uleb128 0x1
 1078 005c 12       		.uleb128 0x12
 1079 005d 06       		.uleb128 0x6
 1080 005e 40       		.uleb128 0x40
 1081 005f 18       		.uleb128 0x18
 1082 0060 9642     		.uleb128 0x2116
 1083 0062 19       		.uleb128 0x19
 1084 0063 01       		.uleb128 0x1
 1085 0064 13       		.uleb128 0x13
 1086 0065 00       		.byte	0
 1087 0066 00       		.byte	0
 1088 0067 09       		.uleb128 0x9
 1089 0068 34       		.uleb128 0x34
 1090 0069 00       		.byte	0
 1091 006a 03       		.uleb128 0x3
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 35


 1092 006b 0E       		.uleb128 0xe
 1093 006c 3A       		.uleb128 0x3a
 1094 006d 0B       		.uleb128 0xb
 1095 006e 3B       		.uleb128 0x3b
 1096 006f 0B       		.uleb128 0xb
 1097 0070 49       		.uleb128 0x49
 1098 0071 13       		.uleb128 0x13
 1099 0072 02       		.uleb128 0x2
 1100 0073 18       		.uleb128 0x18
 1101 0074 00       		.byte	0
 1102 0075 00       		.byte	0
 1103 0076 0A       		.uleb128 0xa
 1104 0077 34       		.uleb128 0x34
 1105 0078 00       		.byte	0
 1106 0079 03       		.uleb128 0x3
 1107 007a 0E       		.uleb128 0xe
 1108 007b 3A       		.uleb128 0x3a
 1109 007c 0B       		.uleb128 0xb
 1110 007d 3B       		.uleb128 0x3b
 1111 007e 0B       		.uleb128 0xb
 1112 007f 49       		.uleb128 0x49
 1113 0080 13       		.uleb128 0x13
 1114 0081 3F       		.uleb128 0x3f
 1115 0082 19       		.uleb128 0x19
 1116 0083 3C       		.uleb128 0x3c
 1117 0084 19       		.uleb128 0x19
 1118 0085 00       		.byte	0
 1119 0086 00       		.byte	0
 1120 0087 00       		.byte	0
 1121              		.section	.debug_aranges,"",%progbits
 1122 0000 1C000000 		.4byte	0x1c
 1123 0004 0200     		.2byte	0x2
 1124 0006 00000000 		.4byte	.Ldebug_info0
 1125 000a 04       		.byte	0x4
 1126 000b 00       		.byte	0
 1127 000c 0000     		.2byte	0
 1128 000e 0000     		.2byte	0
 1129 0010 00000000 		.4byte	.LFB0
 1130 0014 28050000 		.4byte	.LFE0-.LFB0
 1131 0018 00000000 		.4byte	0
 1132 001c 00000000 		.4byte	0
 1133              		.section	.debug_ranges,"",%progbits
 1134              	.Ldebug_ranges0:
 1135 0000 00000000 		.4byte	.LFB0
 1136 0004 28050000 		.4byte	.LFE0
 1137 0008 00000000 		.4byte	0
 1138 000c 00000000 		.4byte	0
 1139              		.section	.debug_line,"",%progbits
 1140              	.Ldebug_line0:
 1141 0000 4D010000 		.section	.debug_str,"MS",%progbits,1
 1141      02008200 
 1141      00000201 
 1141      FB0E0D00 
 1141      01010101 
 1142              	.LASF21:
 1143 0000 49324353 		.ascii	"I2CS_slStatus\000"
 1143      5F736C53 
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 36


 1143      74617475 
 1143      7300
 1144              	.LASF14:
 1145 000e 72656733 		.ascii	"reg32\000"
 1145      3200
 1146              	.LASF29:
 1147 0014 49324353 		.ascii	"I2CS_slOverFlowCount\000"
 1147      5F736C4F 
 1147      76657246 
 1147      6C6F7743 
 1147      6F756E74 
 1148              	.LASF3:
 1149 0029 73686F72 		.ascii	"short unsigned int\000"
 1149      7420756E 
 1149      7369676E 
 1149      65642069 
 1149      6E7400
 1150              	.LASF18:
 1151 003c 656E6454 		.ascii	"endTransfer\000"
 1151      72616E73 
 1151      66657200 
 1152              	.LASF11:
 1153 0048 666C6F61 		.ascii	"float\000"
 1153      7400
 1154              	.LASF1:
 1155 004e 756E7369 		.ascii	"unsigned char\000"
 1155      676E6564 
 1155      20636861 
 1155      7200
 1156              	.LASF24:
 1157 005c 49324353 		.ascii	"I2CS_slWrBufIndex\000"
 1157      5F736C57 
 1157      72427566 
 1157      496E6465 
 1157      7800
 1158              	.LASF5:
 1159 006e 6C6F6E67 		.ascii	"long unsigned int\000"
 1159      20756E73 
 1159      69676E65 
 1159      6420696E 
 1159      7400
 1160              	.LASF17:
 1161 0080 64696666 		.ascii	"diffCount\000"
 1161      436F756E 
 1161      7400
 1162              	.LASF9:
 1163 008a 75696E74 		.ascii	"uint8\000"
 1163      3800
 1164              	.LASF12:
 1165 0090 646F7562 		.ascii	"double\000"
 1165      6C6500
 1166              	.LASF25:
 1167 0097 49324353 		.ascii	"I2CS_slRdBufPtr\000"
 1167      5F736C52 
 1167      64427566 
 1167      50747200 
 1168              	.LASF30:
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 37


 1169 00a7 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 1169      4320342E 
 1169      392E3320 
 1169      32303135 
 1169      30333033 
 1170 00da 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m0 -mthumb -g -O"
 1170      20726576 
 1170      6973696F 
 1170      6E203232 
 1170      31323230 
 1171 010d 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 1171      66756E63 
 1171      74696F6E 
 1171      2D736563 
 1171      74696F6E 
 1172              	.LASF10:
 1173 0135 75696E74 		.ascii	"uint32\000"
 1173      333200
 1174              	.LASF31:
 1175 013c 2E5C4765 		.ascii	".\\Generated_Source\\PSoC4\\I2CS_I2C_INT.c\000"
 1175      6E657261 
 1175      7465645F 
 1175      536F7572 
 1175      63655C50 
 1176              	.LASF8:
 1177 0164 756E7369 		.ascii	"unsigned int\000"
 1177      676E6564 
 1177      20696E74 
 1177      00
 1178              	.LASF7:
 1179 0171 6C6F6E67 		.ascii	"long long unsigned int\000"
 1179      206C6F6E 
 1179      6720756E 
 1179      7369676E 
 1179      65642069 
 1180              	.LASF28:
 1181 0188 49324353 		.ascii	"I2CS_slRdBufIndexTmp\000"
 1181      5F736C52 
 1181      64427566 
 1181      496E6465 
 1181      78546D70 
 1182              	.LASF15:
 1183 019d 63796973 		.ascii	"cyisraddress\000"
 1183      72616464 
 1183      72657373 
 1183      00
 1184              	.LASF33:
 1185 01aa 49324353 		.ascii	"I2CS_I2C_ISR\000"
 1185      5F493243 
 1185      5F495352 
 1185      00
 1186              	.LASF27:
 1187 01b7 49324353 		.ascii	"I2CS_slRdBufIndex\000"
 1187      5F736C52 
 1187      64427566 
 1187      496E6465 
 1187      7800
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 38


 1188              	.LASF16:
 1189 01c9 73697A65 		.ascii	"sizetype\000"
 1189      74797065 
 1189      00
 1190              	.LASF6:
 1191 01d2 6C6F6E67 		.ascii	"long long int\000"
 1191      206C6F6E 
 1191      6720696E 
 1191      7400
 1192              	.LASF13:
 1193 01e0 63686172 		.ascii	"char\000"
 1193      00
 1194              	.LASF20:
 1195 01e5 49324353 		.ascii	"I2CS_state\000"
 1195      5F737461 
 1195      746500
 1196              	.LASF23:
 1197 01f0 49324353 		.ascii	"I2CS_slWrBufSize\000"
 1197      5F736C57 
 1197      72427566 
 1197      53697A65 
 1197      00
 1198              	.LASF2:
 1199 0201 73686F72 		.ascii	"short int\000"
 1199      7420696E 
 1199      7400
 1200              	.LASF22:
 1201 020b 49324353 		.ascii	"I2CS_slWrBufPtr\000"
 1201      5F736C57 
 1201      72427566 
 1201      50747200 
 1202              	.LASF19:
 1203 021b 49324353 		.ascii	"I2CS_customIntrHandler\000"
 1203      5F637573 
 1203      746F6D49 
 1203      6E747248 
 1203      616E646C 
 1204              	.LASF4:
 1205 0232 6C6F6E67 		.ascii	"long int\000"
 1205      20696E74 
 1205      00
 1206              	.LASF0:
 1207 023b 7369676E 		.ascii	"signed char\000"
 1207      65642063 
 1207      68617200 
 1208              	.LASF26:
 1209 0247 49324353 		.ascii	"I2CS_slRdBufSize\000"
 1209      5F736C52 
 1209      64427566 
 1209      53697A65 
 1209      00
 1210              	.LASF32:
 1211 0258 453A5C50 		.ascii	"E:\\Projekt 4. semester\\HellYaeh\\SCB_I2cCommSlave"
 1211      726F6A65 
 1211      6B742034 
 1211      2E207365 
 1211      6D657374 
ARM GAS  C:\Users\Anders\AppData\Local\Temp\ccYakZCl.s 			page 39


 1212 0288 30315C53 		.ascii	"01\\SCB_I2cCommSlave01.cydsn\000"
 1212      43425F49 
 1212      3263436F 
 1212      6D6D536C 
 1212      61766530 
 1213              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
